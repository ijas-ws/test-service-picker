#!/usr/bin/env node
import { createRequire as topLevelCreateRequire } from 'module';
global.require = topLevelCreateRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/context/context.ts
var context_exports = {};
__export(context_exports, {
  Context: () => Context,
  memo: () => memo
});
function create(cb, name) {
  const id = typeof cb === "string" ? cb : name || Symbol(cb?.toString());
  return {
    use() {
      let result = state.contexts.get(id);
      if (!result) {
        if (!cb || typeof cb === "string")
          throw new Error(`"${String(id)}" context was not provided.`);
        state.tracking.push(id);
        const value = cb();
        state.tracking.pop();
        result = {
          value,
          dependants: /* @__PURE__ */ new Set()
        };
        state.contexts.set(id, result);
      }
      const last2 = state.tracking[state.tracking.length - 1];
      if (last2)
        result.dependants.add(last2);
      return result.value;
    },
    provide(value) {
      const requestID = global[Symbol.for("aws.lambda.runtime.requestId")];
      if (state.requestID !== requestID) {
        state.requestID = requestID;
        reset();
      }
      resetDependencies(id);
      state.contexts.set(id, {
        value,
        dependants: /* @__PURE__ */ new Set()
      });
    }
  };
}
function reset() {
  state.contexts.clear();
}
function resetDependencies(id) {
  const info = state.contexts.get(id);
  if (!info)
    return;
  for (const dependantID of info.dependants) {
    resetDependencies(dependantID);
    state.contexts.delete(dependantID);
  }
}
function memo(cb, name) {
  const ctx = create(cb, name);
  return ctx.use;
}
var Context, state;
var init_context = __esm({
  "src/context/context.ts"() {
    "use strict";
    Context = {
      create,
      reset,
      memo
    };
    state = {
      requestID: "",
      contexts: /* @__PURE__ */ new Map(),
      tracking: []
    };
  }
});

// src/logger.ts
var logger_exports = {};
__export(logger_exports, {
  Logger: () => Logger
});
import fs from "fs/promises";
import path from "path";
var previous, useFile, Logger;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    init_context();
    previous = new Date();
    useFile = Context.memo(async () => {
      const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
      const project = useProject2();
      const filePath = path.join(project.paths.out, "debug.log");
      const file = await fs.open(filePath, "w");
      return file;
    });
    Logger = {
      debug(...parts) {
        const now = new Date();
        const diff3 = now.getTime() - previous.getTime();
        previous = now;
        const line = [
          new Date().toISOString(),
          `+${diff3}ms`.padStart(8),
          "[debug]",
          ...parts.map((x) => {
            if (typeof x === "string")
              return x;
            return JSON.stringify(x);
          })
        ];
        if (process.env.SST_VERBOSE)
          console.log(...line);
        useFile().then((file) => {
          file.write(line.join(" ") + "\n");
        });
      }
    };
  }
});

// src/error.ts
var VisibleError;
var init_error = __esm({
  "src/error.ts"() {
    "use strict";
    VisibleError = class extends Error {
      constructor(...message) {
        super(message.join("\n"));
      }
    };
  }
});

// src/util/module.ts
import url from "url";
async function dynamicImport(input) {
  const { href } = url.pathToFileURL(input);
  return import(href);
}
var init_module = __esm({
  "src/util/module.ts"() {
    "use strict";
  }
});

// src/util/fs.ts
var fs_exports = {};
__export(fs_exports, {
  existsAsync: () => existsAsync,
  findAbove: () => findAbove,
  findBelow: () => findBelow,
  isChild: () => isChild
});
import fs2 from "fs/promises";
import path2 from "path";
async function findAbove(dir, target) {
  if (dir === "/")
    return void 0;
  if (await existsAsync(path2.join(dir, target)))
    return dir;
  return findAbove(path2.resolve(path2.join(dir, "..")), target);
}
async function findBelow(dir, target) {
  async function loop(dir2) {
    const current = path2.join(dir2, target);
    if (await existsAsync(current))
      return dir2;
    const files = await fs2.readdir(dir2);
    for (const file of files) {
      if (file === "node_modules")
        continue;
      if (file === ".sst")
        continue;
      const full = path2.join(dir2, file);
      const stat = await fs2.stat(full);
      if (stat.isDirectory()) {
        const result = await loop(full);
        if (result)
          return result;
      }
    }
    return;
  }
  const value = await loop(dir);
  if (!value)
    throw new VisibleError(`Could not find a ${target} file`);
  return value;
}
function isChild(parent, child) {
  const relative = path2.relative(parent, child);
  return Boolean(
    relative && !relative.startsWith("..") && !path2.isAbsolute(relative)
  );
}
async function existsAsync(input) {
  return fs2.access(input).then(() => true).catch(() => false);
}
var init_fs = __esm({
  "src/util/fs.ts"() {
    "use strict";
    init_error();
  }
});

// src/stacks/build.ts
import esbuild from "esbuild";
import fs3 from "fs/promises";
import path3 from "path";
async function load(input) {
  const parsed = path3.parse(input);
  const root = await findAbove(input, "package.json");
  if (!root)
    throw new VisibleError("Could not find a package.json file");
  const outfile = path3.join(parsed.dir, `.${parsed.name}.${Date.now()}.mjs`);
  const pkg = JSON.parse(
    await fs3.readFile(path3.join(root, "package.json")).then((x) => x.toString())
  );
  try {
    const result = await esbuild.build({
      keepNames: true,
      bundle: true,
      sourcemap: "inline",
      platform: "node",
      target: "esnext",
      metafile: true,
      format: "esm",
      logLevel: "silent",
      external: [
        "aws-cdk-lib",
        "sst",
        ...Object.keys({
          ...pkg.devDependencies,
          ...pkg.dependencies,
          ...pkg.peerDependencies
        })
      ],
      absWorkingDir: root,
      outfile,
      banner: {
        js: [
          `import { createRequire as topLevelCreateRequire } from 'module';`,
          `const require = topLevelCreateRequire(import.meta.url);`
        ].join("")
      },
      entryPoints: [input]
    });
    const mod = await dynamicImport(outfile);
    await fs3.rm(outfile, {
      force: true
    });
    if (!mod.default?.config)
      throw new VisibleError(
        `The config file is improperly formatted.`,
        `Example:`,
        `export default {`,
        `  config() {`,
        `    return {`,
        `      name: "my-app",`,
        `      region: "us-east-1"`,
        `    }`,
        `  },`,
        `  stacks(app) {`,
        `  }`,
        `}`
      );
    return [result.metafile, mod.default];
  } catch (e) {
    await fs3.rm(outfile, {
      force: true
    });
    throw e;
  }
}
var init_build = __esm({
  "src/stacks/build.ts"() {
    "use strict";
    init_module();
    init_fs();
    init_error();
  }
});

// src/project.ts
var project_exports = {};
__export(project_exports, {
  ProjectContext: () => ProjectContext,
  exportedForTesting: () => exportedForTesting,
  initProject: () => initProject,
  useProject: () => useProject
});
import fs4 from "fs/promises";
import fsSync from "fs";
import path4 from "path";
import url2 from "url";
import os from "os";
import { blue } from "colorette";
import dotenv from "dotenv";
function useProject() {
  return ProjectContext.use();
}
async function initProject(globals) {
  const root = globals.root || await findRoot();
  const out = path4.join(root, ".sst");
  await fs4.mkdir(out, {
    recursive: true
  });
  let file;
  const [metafile, sstConfig] = await async function() {
    for (const ext of CONFIG_EXTENSIONS) {
      file = path4.join(root, "sst" + ext);
      if (!fsSync.existsSync(file))
        continue;
      const [metafile2, config2] = await load(file);
      return [metafile2, config2];
    }
    throw new VisibleError(
      "Could not found a configuration file",
      "Make sure one of the following exists",
      ...CONFIG_EXTENSIONS.map((x) => `  - sst${x}`)
    );
  }();
  const config = await Promise.resolve(sstConfig.config(globals));
  const stage = globals.stage || config.stage || await usePersonalStage(out) || await promptPersonalStage(out);
  const [version2, cdkVersion, constructsVersion] = await (async () => {
    try {
      const packageJson = JSON.parse(
        await fs4.readFile(
          url2.fileURLToPath(new URL("./package.json", import.meta.url))
        ).then((x) => x.toString())
      );
      return [
        packageJson.version,
        packageJson.dependencies["aws-cdk-lib"],
        packageJson.dependencies["constructs"]
      ];
    } catch {
      return ["unknown", "unknown"];
    }
  })();
  const project = {
    version: version2,
    cdkVersion,
    constructsVersion,
    config: {
      ...config,
      stage,
      profile: process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY ? void 0 : globals.profile || config.profile,
      region: globals.region || config.region,
      role: globals.role || config.role,
      ssmPrefix: config.ssmPrefix || `/sst/${config.name}/${stage}/`,
      bootstrap: config.bootstrap,
      cdk: config.cdk
    },
    stacks: sstConfig.stacks,
    metafile,
    paths: {
      config: file,
      root,
      out,
      artifacts: path4.join(out, "artifacts")
    }
  };
  (async function() {
    const files = await fs4.readdir(project.paths.root);
    for (const file2 of files) {
      if (file2.startsWith(".sst.config")) {
        await fs4.unlink(path4.join(project.paths.root, file2));
        Logger.debug(`Removed old config file ${file2}`);
      }
    }
  })();
  ProjectContext.provide(project);
  dotenv.config({
    path: path4.join(project.paths.root, `.env.${project.config.stage}`),
    override: true
  });
  dotenv.config({
    path: path4.join(project.paths.root, `.env.${project.config.stage}.local`),
    override: true
  });
  Logger.debug("Config loaded", project);
}
async function usePersonalStage(out) {
  try {
    const result = await fs4.readFile(path4.join(out, "stage"));
    return result.toString("utf8").trim();
  } catch {
    return;
  }
}
async function promptPersonalStage(out, isRetry) {
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  const stage = await new Promise((resolve) => {
    const suggested = sanitizeStageName(os.userInfo().username) || "local";
    const instruction = !isRetry ? `Please enter a name you\u2019d like to use for your personal stage.` : `Please enter a name that starts with a letter, followed by letters, numbers, or hyphens.`;
    rl.question(
      `${instruction} Or hit enter to use ${blue(suggested)}: `,
      async (input) => {
        rl.close();
        const result = input === "" ? suggested : input;
        resolve(result);
      }
    );
  });
  if (isValidStageName(stage)) {
    await fs4.writeFile(path4.join(out, "stage"), stage);
    return stage;
  }
  return await promptPersonalStage(out, true);
}
async function findRoot() {
  async function find2(dir) {
    if (dir === "/")
      throw new VisibleError(
        "Could not found a configuration file",
        "Make sure one of the following exists",
        ...CONFIG_EXTENSIONS.map((ext) => `  - sst${ext}`)
      );
    for (const ext of CONFIG_EXTENSIONS) {
      const configPath = path4.join(dir, `sst${ext}`);
      if (fsSync.existsSync(configPath)) {
        return dir;
      }
    }
    return await find2(path4.join(dir, ".."));
  }
  const result = await find2(process.cwd());
  return result;
}
function sanitizeStageName(stage) {
  return stage.replace(/[^A-Za-z0-9-]/g, "-").replace(/--+/g, "-").replace(/^[^A-Za-z]/, "").replace(/-$/, "") || "local";
}
function isValidStageName(stage) {
  return Boolean(stage.match(/^[A-Za-z][A-Za-z0-9-]*$/));
}
var ProjectContext, CONFIG_EXTENSIONS, exportedForTesting;
var init_project = __esm({
  "src/project.ts"() {
    "use strict";
    init_logger();
    init_context();
    init_error();
    init_build();
    ProjectContext = Context.create("Project");
    CONFIG_EXTENSIONS = [
      ".config.ts",
      ".config.mts",
      ".config.cts",
      ".config.cjs",
      ".config.mjs",
      ".config.js"
    ];
    exportedForTesting = {
      sanitizeStageName,
      isValidStageName
    };
  }
});

// src/cli/telemetry/post-payload.ts
import https from "https";
function postPayload(endpoint, body) {
  return new Promise((resolve, reject) => {
    try {
      const req = https.request(
        endpoint,
        {
          method: "POST",
          headers: { "content-type": "application/json" },
          timeout: 5e3
        },
        (resp) => {
          if (resp.statusCode !== 200) {
            reject(new Error(`Unexpected status code: ${resp.statusCode}`));
            return;
          }
          resolve();
        }
      );
      req.write(JSON.stringify(body));
      req.end();
    } catch (ex) {
      reject(ex);
    }
  });
}
var init_post_payload = __esm({
  "src/cli/telemetry/post-payload.ts"() {
    "use strict";
  }
});

// src/cli/telemetry/project-id.ts
import { execSync } from "child_process";
function getProjectIdByGit() {
  try {
    const originBuffer = execSync(
      `git config --local --get remote.origin.url`,
      {
        timeout: 1e3,
        stdio: `pipe`
      }
    );
    return String(originBuffer).trim();
  } catch (_) {
    return null;
  }
}
function normalizeGitUrl(url10) {
  url10 = url10.trim();
  url10 = url10.endsWith(".git") ? url10.substring(0, url10.length - 4) : url10;
  if (url10.startsWith("git@")) {
    const match = url10.match(/git@([^:]+):(.*)/);
    if (match && match.length > 2) {
      return `${match[1]}/${match[2]}`;
    }
  } else if (url10.startsWith("http://") || url10.startsWith("https://")) {
    const match = url10.match(/https?:\/\/([^@]+@)?(.*)/);
    if (match && match.length > 2) {
      return match[2];
    }
  }
  return url10;
}
function getRawProjectId() {
  const gitUrl = getProjectIdByGit();
  if (gitUrl) {
    return normalizeGitUrl(gitUrl);
  }
  const repoUrl = process.env.REPOSITORY_URL;
  if (repoUrl) {
    return normalizeGitUrl(repoUrl);
  }
  return process.cwd();
}
var init_project_id = __esm({
  "src/cli/telemetry/project-id.ts"() {
    "use strict";
  }
});

// src/cli/ci-info.ts
var ci_info_exports = {};
__export(ci_info_exports, {
  getCiInfo: () => getCiInfo
});
import ciInfo from "ci-info";
function getCiInfo() {
  const isSeed = !!process.env.SEED_APP_NAME;
  return {
    isCI: ciInfo.isCI || isSeed,
    name: (isSeed ? "Seed" : ciInfo.name) || null
  };
}
var init_ci_info = __esm({
  "src/cli/ci-info.ts"() {
    "use strict";
  }
});

// src/cli/telemetry/environment.ts
import os2 from "os";
function getEnvironmentData() {
  if (data) {
    return data;
  }
  const cpus = os2.cpus() || [];
  const ciInfo2 = getCiInfo();
  data = {
    systemPlatform: os2.platform(),
    systemRelease: os2.release(),
    systemArchitecture: os2.arch(),
    cpuCount: cpus.length,
    cpuModel: cpus.length ? cpus[0].model : null,
    cpuSpeed: cpus.length ? cpus[0].speed : null,
    memoryInMb: Math.trunc(os2.totalmem() / Math.pow(1024, 2)),
    isCI: ciInfo2.isCI,
    ciName: ciInfo2.name,
    sstVersion: useProject().version
  };
  return data;
}
var data;
var init_environment = __esm({
  "src/cli/telemetry/environment.ts"() {
    "use strict";
    init_ci_info();
    init_project();
  }
});

// src/cli/telemetry/telemetry.ts
var telemetry_exports = {};
__export(telemetry_exports, {
  disable: () => disable,
  enable: () => enable,
  isEnabled: () => isEnabled,
  trackCli: () => trackCli
});
import Conf from "conf";
import { createHash, randomBytes } from "crypto";
import { cyan } from "colorette";
function enable() {
  conf && conf.set(TELEMETRY_KEY_ENABLED, true);
}
function disable() {
  conf && conf.set(TELEMETRY_KEY_ENABLED, false);
}
function isEnabled() {
  if (!conf) {
    return false;
  }
  return conf.get(TELEMETRY_KEY_ENABLED, true) !== false;
}
function trackCli(command) {
  record("CLI_COMMAND", {
    command
  });
}
function initializeConf() {
  try {
    return new Conf({ projectName: "sst" });
  } catch (_) {
    return null;
  }
}
function notify() {
  if (!conf || willNotRecord()) {
    return;
  }
  if (conf.get(TELEMETRY_KEY_NOTIFY_DATE) !== void 0) {
    return;
  }
  conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString());
  console.log(
    `${cyan(
      "Attention"
    )}: SST now collects completely anonymous telemetry regarding usage. This is used to guide SST's roadmap.`
  );
  console.log(
    `You can learn more, including how to opt-out of this anonymous program, by heading over to:`
  );
  console.log("https://docs.sst.dev/anonymous-telemetry");
  console.log();
}
function willNotRecord() {
  return !isEnabled() || !!process.env.SST_TELEMETRY_DISABLED;
}
async function record(name, properties) {
  if (willNotRecord()) {
    return Promise.resolve();
  }
  const context = {
    anonymousId,
    projectId,
    sessionId
  };
  try {
    await postPayload(TELEMETRY_API, {
      context,
      environment: getEnvironmentData(),
      events: [
        {
          name,
          properties
        }
      ]
    });
  } catch {
  }
}
function getAnonymousId() {
  const val = conf && conf.get(TELEMETRY_KEY_ID);
  if (val) {
    return val;
  }
  const generated = randomBytes(32).toString("hex");
  conf && conf.set(TELEMETRY_KEY_ID, generated);
  return generated;
}
function hash(payload) {
  return createHash("sha256").update(payload).digest("hex");
}
var TELEMETRY_API, TELEMETRY_KEY_ENABLED, TELEMETRY_KEY_NOTIFY_DATE, TELEMETRY_KEY_ID, conf, sessionId, projectId, anonymousId;
var init_telemetry = __esm({
  "src/cli/telemetry/telemetry.ts"() {
    "use strict";
    init_post_payload();
    init_project_id();
    init_environment();
    TELEMETRY_API = "https://telemetry.sst.dev/events";
    TELEMETRY_KEY_ENABLED = "telemetry.enabled";
    TELEMETRY_KEY_NOTIFY_DATE = "telemetry.notifiedAt";
    TELEMETRY_KEY_ID = `telemetry.anonymousId`;
    conf = initializeConf();
    sessionId = randomBytes(32).toString("hex");
    projectId = hash(getRawProjectId());
    anonymousId = getAnonymousId();
    notify();
  }
});

// src/cli/colors.ts
var colors_exports = {};
__export(colors_exports, {
  Colors: () => Colors
});
import chalk from "chalk";
var last, Colors;
var init_colors = __esm({
  "src/cli/colors.ts"() {
    "use strict";
    last = "gap";
    Colors = {
      line: (message, ...optionalParams) => {
        last = "line";
        console.log(message, ...optionalParams);
      },
      mode(input) {
        last = input;
      },
      gap() {
        if (last === "line") {
          last = "gap";
          console.log();
        }
      },
      hex: chalk.hex,
      primary: chalk.hex("#FF9000"),
      link: chalk.cyan,
      success: chalk.green,
      danger: chalk.red,
      warning: chalk.yellow,
      dim: chalk.dim,
      bold: chalk.bold,
      all: chalk,
      prefix: chalk.bold("| ")
    };
  }
});

// src/cli/spinner.ts
var spinner_exports = {};
__export(spinner_exports, {
  createSpinner: () => createSpinner,
  useSpinners: () => useSpinners
});
import ora from "ora";
function createSpinner(options) {
  const spinners = useSpinners();
  const next = ora(options);
  spinners.push(next);
  Colors.mode("line");
  return next;
}
var useSpinners;
var init_spinner = __esm({
  "src/cli/spinner.ts"() {
    "use strict";
    init_context();
    init_colors();
    useSpinners = Context.memo(() => {
      const spinners = [];
      return spinners;
    });
  }
});

// ../../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.push(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.push(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator2) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator2.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state2, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
}
function __classPrivateFieldSet(receiver, state2, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
var extendStatics, __assign, __createBinding, __setModuleDefault;
var init_tslib_es6 = __esm({
  "../../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/abort.js
var require_abort = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/abort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/auth.js
var require_auth = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpAuthLocation = void 0;
    var HttpAuthLocation;
    (function(HttpAuthLocation2) {
      HttpAuthLocation2["HEADER"] = "header";
      HttpAuthLocation2["QUERY"] = "query";
    })(HttpAuthLocation = exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/checksum.js
var require_checksum = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/checksum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/client.js
var require_client = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/command.js
var require_command = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/credentials.js
var require_credentials = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/crypto.js
var require_crypto = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/dns.js
var require_dns = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/dns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HostAddressType = void 0;
    var HostAddressType;
    (function(HostAddressType2) {
      HostAddressType2["AAAA"] = "AAAA";
      HostAddressType2["A"] = "A";
    })(HostAddressType = exports.HostAddressType || (exports.HostAddressType = {}));
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/endpoint.js
var require_endpoint = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/endpoint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EndpointURLScheme = void 0;
    var EndpointURLScheme;
    (function(EndpointURLScheme2) {
      EndpointURLScheme2["HTTP"] = "http";
      EndpointURLScheme2["HTTPS"] = "https";
    })(EndpointURLScheme = exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/eventStream.js
var require_eventStream = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/eventStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/http.js
var require_http = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/AnonymousIdentity.js
var require_AnonymousIdentity = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/AnonymousIdentity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/AwsCredentialIdentity.js
var require_AwsCredentialIdentity = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/AwsCredentialIdentity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/Identity.js
var require_Identity = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/Identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/LoginIdentity.js
var require_LoginIdentity = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/LoginIdentity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/TokenIdentity.js
var require_TokenIdentity = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/TokenIdentity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/index.js
var require_identity = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/identity/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_AnonymousIdentity(), exports);
    tslib_1.__exportStar(require_AwsCredentialIdentity(), exports);
    tslib_1.__exportStar(require_Identity(), exports);
    tslib_1.__exportStar(require_LoginIdentity(), exports);
    tslib_1.__exportStar(require_TokenIdentity(), exports);
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/logger.js
var require_logger = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/middleware.js
var require_middleware = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/middleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/pagination.js
var require_pagination = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/pagination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/profile.js
var require_profile = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/profile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/request.js
var require_request = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/response.js
var require_response = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/retry.js
var require_retry = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/serde.js
var require_serde = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/serde.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/shapes.js
var require_shapes = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/shapes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/signature.js
var require_signature = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/stream.js
var require_stream = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/token.js
var require_token = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/transfer.js
var require_transfer = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/transfer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/waiter.js
var require_waiter = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/waiter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "../../node_modules/.pnpm/@aws-sdk+types@3.272.0/node_modules/@aws-sdk/types/dist-cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_abort(), exports);
    tslib_1.__exportStar(require_auth(), exports);
    tslib_1.__exportStar(require_checksum(), exports);
    tslib_1.__exportStar(require_client(), exports);
    tslib_1.__exportStar(require_command(), exports);
    tslib_1.__exportStar(require_credentials(), exports);
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_dns(), exports);
    tslib_1.__exportStar(require_endpoint(), exports);
    tslib_1.__exportStar(require_eventStream(), exports);
    tslib_1.__exportStar(require_http(), exports);
    tslib_1.__exportStar(require_identity(), exports);
    tslib_1.__exportStar(require_logger(), exports);
    tslib_1.__exportStar(require_middleware(), exports);
    tslib_1.__exportStar(require_pagination(), exports);
    tslib_1.__exportStar(require_profile(), exports);
    tslib_1.__exportStar(require_request(), exports);
    tslib_1.__exportStar(require_response(), exports);
    tslib_1.__exportStar(require_retry(), exports);
    tslib_1.__exportStar(require_serde(), exports);
    tslib_1.__exportStar(require_shapes(), exports);
    tslib_1.__exportStar(require_signature(), exports);
    tslib_1.__exportStar(require_stream(), exports);
    tslib_1.__exportStar(require_token(), exports);
    tslib_1.__exportStar(require_transfer(), exports);
    tslib_1.__exportStar(require_util(), exports);
    tslib_1.__exportStar(require_waiter(), exports);
  }
});

// src/credentials.ts
var credentials_exports = {};
__export(credentials_exports, {
  useAWSClient: () => useAWSClient,
  useAWSCredentials: () => useAWSCredentials,
  useAWSCredentialsProvider: () => useAWSCredentialsProvider,
  useAWSProvider: () => useAWSProvider,
  useSTSIdentity: () => useSTSIdentity
});
import { fromNodeProviderChain } from "@aws-sdk/credential-providers";
import { GetCallerIdentityCommand, STSClient } from "@aws-sdk/client-sts";
import { SdkProvider } from "sst-aws-cdk/lib/api/aws-auth/sdk-provider.js";
import { StandardRetryStrategy } from "@aws-sdk/middleware-retry";
import stupid from "aws-sdk/lib/maintenance_mode_message.js";
import aws from "aws-sdk";
function useAWSClient(client, force = false) {
  const cache = useClientCache();
  const existing = cache.get(client.name);
  if (existing && !force)
    return existing;
  const [project, credentials] = [useProject(), useAWSCredentialsProvider()];
  const printNoInternet = (() => {
    let lastPrinted = 0;
    return () => {
      const now = Date.now();
      if (now - lastPrinted > 5e3) {
        console.log("Waiting for internet connection...");
        lastPrinted = now;
      }
    };
  })();
  const result = new client({
    region: project.config.region,
    credentials,
    retryStrategy: new StandardRetryStrategy(async () => 1e4, {
      retryDecider: (e) => {
        if (e.code === "ENOTFOUND") {
          printNoInternet();
          return true;
        }
        if ([
          "ThrottlingException",
          "Throttling",
          "TooManyRequestsException",
          "OperationAbortedException",
          "TimeoutError",
          "NetworkingError"
        ].includes(e.name)) {
          Logger.debug("Retry AWS call", e.name, e.message);
          return true;
        }
        return false;
      },
      delayDecider: (_, attempts) => {
        return Math.min(1.5 ** attempts * 100, 5e3);
      },
      retryQuota: {
        hasRetryTokens: () => true,
        releaseRetryTokens: () => {
        },
        retrieveRetryTokens: () => 1
      }
    })
  });
  cache.set(client.name, result);
  Logger.debug("Created AWS client", client.name);
  return result;
}
var import_types, useAWSCredentialsProvider, useAWSCredentials, useSTSIdentity, useClientCache, CredentialProviderChain, useAWSProvider;
var init_credentials = __esm({
  "src/credentials.ts"() {
    "use strict";
    import_types = __toESM(require_dist_cjs(), 1);
    init_context();
    init_logger();
    init_project();
    useAWSCredentialsProvider = Context.memo(() => {
      const project = useProject();
      Logger.debug("Using AWS profile", project.config.profile);
      const provider = fromNodeProviderChain({
        profile: project.config.profile,
        roleArn: project.config.role,
        mfaCodeProvider: async (serialArn) => {
          const readline = await import("readline");
          const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
          });
          return new Promise((resolve) => {
            Logger.debug(`Require MFA token for serial ARN ${serialArn}`);
            const prompt = () => rl.question(`Enter MFA code for ${serialArn}: `, async (input) => {
              if (input.trim() !== "") {
                resolve(input.trim());
                rl.close();
              } else {
                prompt();
              }
            });
            prompt();
          });
        }
      });
      return provider;
    });
    useAWSCredentials = () => {
      const provider = useAWSCredentialsProvider();
      return provider();
    };
    useSTSIdentity = Context.memo(async () => {
      const sts = useAWSClient(STSClient);
      const identity = await sts.send(new GetCallerIdentityCommand({}));
      Logger.debug(
        "Using identity",
        "Account:",
        identity.Account,
        "User:",
        identity.UserId
      );
      return identity;
    });
    useClientCache = Context.memo(() => /* @__PURE__ */ new Map());
    stupid.suppress = true;
    CredentialProviderChain = aws.CredentialProviderChain;
    useAWSProvider = Context.memo(async () => {
      Logger.debug("Loading v2 AWS SDK");
      const project = useProject();
      const creds = await useAWSCredentials();
      const chain = new CredentialProviderChain([
        () => ({
          ...creds,
          get(cb) {
            cb();
          },
          async getPromise() {
          },
          needsRefresh() {
            return false;
          },
          refresh(cb) {
            cb();
          },
          async refreshPromise() {
          },
          expired: false,
          expireTime: creds.expiration,
          accessKeyId: creds.accessKeyId,
          sessionToken: creds.sessionToken,
          secretAccessKey: creds.secretAccessKey
        })
      ]);
      const provider = new SdkProvider(chain, project.config.region, {
        maxRetries: 1e4,
        region: project.config.region
      });
      return provider;
    });
  }
});

// src/stacks/app-metadata.ts
import {
  S3Client,
  GetObjectCommand,
  PutObjectCommand,
  DeleteObjectCommand
} from "@aws-sdk/client-s3";
async function metadata() {
  Logger.debug("Fetching app metadata");
  const [project, credentials, bootstrap2] = await Promise.all([
    useProject(),
    useAWSCredentials(),
    useBootstrap()
  ]);
  const s3 = new S3Client({
    region: project.config.region,
    credentials
  });
  try {
    const result = await s3.send(
      new GetObjectCommand({
        Key: useS3Key(),
        Bucket: bootstrap2.bucket
      })
    );
    const body = await result.Body.transformToString();
    return JSON.parse(body);
  } catch (ex) {
    Logger.debug("Fetching app metadata: not found");
  }
}
async function saveAppMetadata(data2) {
  Logger.debug("Saving app metadata");
  const [project, credentials, bootstrap2] = await Promise.all([
    useProject(),
    useAWSCredentials(),
    useBootstrap()
  ]);
  const s3 = new S3Client({
    region: project.config.region,
    credentials
  });
  try {
    await s3.send(
      new PutObjectCommand({
        Key: useS3Key(),
        Bucket: bootstrap2.bucket,
        Body: JSON.stringify(data2)
      })
    );
  } catch (ex) {
    Logger.debug("Saving app metadata: not found");
  }
}
async function clearAppMetadata() {
  Logger.debug("Clearing app metadata");
  const [project, credentials, bootstrap2] = await Promise.all([
    useProject(),
    useAWSCredentials(),
    useBootstrap()
  ]);
  const s3 = new S3Client({
    region: project.config.region,
    credentials
  });
  await s3.send(
    new DeleteObjectCommand({
      Key: useS3Key(),
      Bucket: bootstrap2.bucket
    })
  );
}
function useS3Key() {
  const project = useProject();
  return `appMetadata/app.${project.config.name}/stage.${project.config.stage}.json`;
}
var MetadataContext, useAppMetadata;
var init_app_metadata = __esm({
  "src/stacks/app-metadata.ts"() {
    "use strict";
    init_bootstrap();
    init_credentials();
    init_context();
    init_logger();
    init_project();
    MetadataContext = Context.create(async () => {
      const data2 = await metadata();
      return data2;
    });
    useAppMetadata = MetadataContext.use;
  }
});

// src/stacks/assembly.ts
async function loadAssembly(from) {
  const { CloudAssembly } = await import("aws-cdk-lib/cx-api");
  return new CloudAssembly(from);
}
var init_assembly = __esm({
  "src/stacks/assembly.ts"() {
    "use strict";
  }
});

// src/bus.ts
var bus_exports = {};
__export(bus_exports, {
  useBus: () => useBus
});
import crypto from "crypto";
var DO_NOT_LOG, useBus;
var init_bus = __esm({
  "src/bus.ts"() {
    "use strict";
    init_context();
    init_logger();
    DO_NOT_LOG = /* @__PURE__ */ new Set(["stacks.metadata"]);
    useBus = Context.memo(() => {
      const subscriptions = {};
      function subscribers(type) {
        let arr = subscriptions[type];
        if (!arr) {
          arr = [];
          subscriptions[type] = arr;
        }
        return arr;
      }
      const sourceID = crypto.randomBytes(16).toString("hex");
      const result = {
        sourceID,
        publish(type, properties) {
          const payload = {
            type,
            properties,
            sourceID
          };
          if (!DO_NOT_LOG.has(type)) {
            Logger.debug(`Publishing event ${JSON.stringify(payload)}`);
          }
          for (const sub of subscribers(type))
            sub.cb(payload);
        },
        unsubscribe(sub) {
          const arr = subscribers(sub.type);
          const index = arr.indexOf(sub);
          if (index < 0)
            return;
          arr.splice(index, 1);
        },
        subscribe(type, cb) {
          const sub = {
            type,
            cb
          };
          subscribers(type).push(sub);
          return sub;
        },
        forward(..._types) {
          return (type, cb) => {
            return this.subscribe(type, cb);
          };
        }
      };
      return result;
    });
  }
});

// src/stacks/monitor.ts
import {
  CloudFormationClient,
  DescribeStackResourcesCommand,
  DescribeStacksCommand,
  DescribeStackEventsCommand
} from "@aws-sdk/client-cloudformation";
import { map, omitBy, pipe } from "remeda";
function isFinal(input) {
  return STATUSES_SUCCESS.includes(input) || STATUSES_FAILED.includes(input);
}
function isFailed(input) {
  return STATUSES_FAILED.includes(input);
}
function isSuccess(input) {
  return STATUSES_SUCCESS.includes(input);
}
function isPending(input) {
  return STATUSES_PENDING.includes(input);
}
async function monitor(stack) {
  const [cfn, bus] = await Promise.all([
    useAWSClient(CloudFormationClient),
    useBus()
  ]);
  let lastStatus;
  const errors = {};
  let lastEvent;
  while (true) {
    try {
      const [describe, resources, events] = await Promise.all([
        cfn.send(
          new DescribeStacksCommand({
            StackName: stack
          })
        ),
        cfn.send(
          new DescribeStackResourcesCommand({
            StackName: stack
          })
        ),
        cfn.send(
          new DescribeStackEventsCommand({
            StackName: stack
          })
        )
      ]);
      Logger.debug("Stack description", describe);
      if (lastEvent) {
        const eventsReversed = [...events.StackEvents ?? []].reverse();
        for (const event of eventsReversed) {
          if (!event.Timestamp)
            continue;
          if (event.Timestamp.getTime() > lastEvent.getTime()) {
            bus.publish("stack.event", {
              event,
              stackID: stack
            });
            if (event.ResourceStatusReason) {
              if (event.ResourceStatusReason.includes(
                "Resource creation cancelled"
              ) || event.ResourceStatusReason.includes(
                "Resource update cancelled"
              ) || event.ResourceStatusReason.includes(
                "Resource creation Initiated"
              ) || event.ResourceStatusReason.startsWith(
                "The following resource(s) failed to"
              ))
                continue;
              errors[event.LogicalResourceId] = event.ResourceStatusReason;
            }
          }
        }
        Logger.debug("Last event set to", lastEvent);
      }
      lastEvent = events.StackEvents?.at(0)?.Timestamp;
      bus.publish("stack.resources", {
        stackID: stack,
        resources: resources.StackResources
      });
      for (const resource of resources.StackResources || []) {
        if (resource.ResourceStatusReason?.includes(
          "Resource creation cancelled"
        ) || resource.ResourceStatusReason?.includes(
          "Resource update cancelled"
        ) || resource.ResourceStatusReason?.includes(
          "Resource creation Initiated"
        ) || resource.ResourceStatusReason?.startsWith(
          "The following resource(s) failed to"
        ))
          continue;
        if (resource.ResourceStatusReason)
          errors[resource.LogicalResourceId] = resource.ResourceStatusReason;
      }
      const [first] = describe.Stacks || [];
      if (first) {
        if (lastStatus !== first.StackStatus && first.StackStatus) {
          lastStatus = first.StackStatus;
          bus.publish("stack.status", {
            stackID: stack,
            status: first.StackStatus
          });
          Logger.debug(first);
          if (isFinal(first.StackStatus)) {
            return {
              status: first.StackStatus,
              outputs: pipe(
                first.Outputs || [],
                map((o) => [o.OutputKey, o.OutputValue]),
                Object.fromEntries,
                filterOutputs
              ),
              errors: isFailed(first.StackStatus) ? errors : {}
            };
          }
        }
      }
    } catch (ex) {
      if (ex.message.includes("does not exist")) {
        bus.publish("stack.status", {
          stackID: stack,
          status: "DELETE_COMPLETE"
        });
        return {
          status: "DELETE_COMPLETE",
          outputs: {},
          errors: {}
        };
      }
      throw ex;
    }
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
}
function filterOutputs(input) {
  return pipe(
    input,
    omitBy((_, key) => {
      return key.startsWith("Export") || key === "SSTMetadata";
    })
  );
}
var STATUSES_PENDING, STATUSES_SUCCESS, STATUSES_FAILED, STATUSES;
var init_monitor = __esm({
  "src/stacks/monitor.ts"() {
    "use strict";
    init_bus();
    init_credentials();
    init_logger();
    STATUSES_PENDING = [
      "CREATE_IN_PROGRESS",
      "DELETE_IN_PROGRESS",
      "REVIEW_IN_PROGRESS",
      "ROLLBACK_IN_PROGRESS",
      "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS",
      "UPDATE_IN_PROGRESS",
      "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS",
      "UPDATE_ROLLBACK_IN_PROGRESS"
    ];
    STATUSES_SUCCESS = [
      "CREATE_COMPLETE",
      "UPDATE_COMPLETE",
      "DELETE_COMPLETE",
      "SKIPPED"
    ];
    STATUSES_FAILED = [
      "CREATE_FAILED",
      "DELETE_FAILED",
      "ROLLBACK_FAILED",
      "ROLLBACK_COMPLETE",
      "UPDATE_FAILED",
      "UPDATE_ROLLBACK_COMPLETE",
      "UPDATE_ROLLBACK_FAILED",
      "DEPENDENCY_FAILED"
    ];
    STATUSES = [
      ...STATUSES_PENDING,
      ...STATUSES_SUCCESS,
      ...STATUSES_FAILED
    ];
  }
});

// src/cdk/util.ts
async function callWithRetry(cb) {
  try {
    return await cb();
  } catch (e) {
    if (e.code === "ThrottlingException" && e.message === "Rate exceeded" || e.code === "Throttling" && e.message === "Rate exceeded" || e.code === "TooManyRequestsException" && e.message === "Too Many Requests" || e.code === "OperationAbortedException" || e.code === "TimeoutError" || e.code === "NetworkingError") {
      return await callWithRetry(cb);
    }
    throw e;
  }
}
var init_util = __esm({
  "src/cdk/util.ts"() {
    "use strict";
  }
});

// src/cdk/deploy-stack.ts
import * as cxapi from "@aws-cdk/cx-api";
import fs5 from "fs/promises";
import * as uuid from "uuid";
import { addMetadataAssetsToManifest } from "sst-aws-cdk/lib/assets.js";
import { debug, error, print } from "sst-aws-cdk/lib/logging.js";
import { toYAML } from "sst-aws-cdk/lib/serialize.js";
import { AssetManifestBuilder } from "sst-aws-cdk/lib/util/asset-manifest-builder.js";
import { publishAssets } from "sst-aws-cdk/lib/util/asset-publishing.js";
import { contentHash } from "sst-aws-cdk/lib/util/content-hash.js";
import { CfnEvaluationException } from "sst-aws-cdk/lib/api/evaluate-cloudformation-template.js";
import { tryHotswapDeployment } from "sst-aws-cdk/lib/api/hotswap-deployments.js";
import {
  changeSetHasNoChanges,
  CloudFormationStack,
  TemplateParameters,
  waitForChangeSet,
  waitForStackDeploy,
  waitForStackDelete
} from "sst-aws-cdk/lib/api/util/cloudformation.js";
import { blue as blue2 } from "colorette";
async function deployStack(options) {
  const stackArtifact = options.stack;
  const stackEnv = options.resolvedEnvironment;
  options.sdk.appendCustomUserAgent(options.extraUserAgent);
  const cfn = options.sdk.cloudFormation();
  const deployName = options.deployName || stackArtifact.stackName;
  let cloudFormationStack = await callWithRetry(
    () => CloudFormationStack.lookup(cfn, deployName)
  );
  if (cloudFormationStack.stackStatus.isCreationFailure) {
    debug(
      `Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`
    );
    await cfn.deleteStack({ StackName: deployName }).promise();
    const deletedStack = await waitForStackDelete(cfn, deployName);
    if (deletedStack && deletedStack.stackStatus.name !== "DELETE_COMPLETE") {
      throw new Error(
        `Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`
      );
    }
    cloudFormationStack = CloudFormationStack.doesNotExist(cfn, deployName);
  }
  const legacyAssets = new AssetManifestBuilder();
  const assetParams = await addMetadataAssetsToManifest(
    stackArtifact,
    legacyAssets,
    options.toolkitInfo,
    options.reuseAssets
  );
  const finalParameterValues = { ...options.parameters, ...assetParams };
  const templateParams = TemplateParameters.fromTemplate(
    stackArtifact.template
  );
  const stackParams = options.usePreviousParameters ? templateParams.updateExisting(
    finalParameterValues,
    cloudFormationStack.parameters
  ) : templateParams.supplyAll(finalParameterValues);
  if (await canSkipDeploy(
    options,
    cloudFormationStack,
    stackParams.hasChanges(cloudFormationStack.parameters)
  )) {
    debug(`${deployName}: skipping deployment (use --force to override)`);
    if (options.hotswap) {
    }
    return {
      noOp: true,
      outputs: cloudFormationStack.outputs,
      stackArn: cloudFormationStack.stackId
    };
  } else {
    debug(`${deployName}: deploying...`);
  }
  const bodyParameter = await makeBodyParameter(
    stackArtifact,
    options.resolvedEnvironment,
    legacyAssets,
    options.toolkitInfo,
    options.sdk,
    options.overrideTemplate
  );
  await publishAssets(
    legacyAssets.toManifest(stackArtifact.assembly.directory),
    options.sdkProvider,
    stackEnv,
    {
      parallel: options.assetParallelism
    }
  );
  if (options.hotswap) {
    try {
      const hotswapDeploymentResult = await tryHotswapDeployment(
        options.sdkProvider,
        assetParams,
        cloudFormationStack,
        stackArtifact
      );
      if (hotswapDeploymentResult) {
        return hotswapDeploymentResult;
      }
      print(
        "Could not perform a hotswap deployment, as the stack %s contains non-Asset changes",
        stackArtifact.displayName
      );
    } catch (e) {
      if (!(e instanceof CfnEvaluationException)) {
        throw e;
      }
      print(
        "Could not perform a hotswap deployment, because the CloudFormation template could not be resolved: %s",
        e.message
      );
    }
    print("Falling back to doing a full deployment");
    options.sdk.appendCustomUserAgent("cdk-hotswap/fallback");
  }
  const fullDeployment = new FullCloudFormationDeployment(
    options,
    cloudFormationStack,
    stackArtifact,
    stackParams,
    bodyParameter
  );
  return fullDeployment.performDeployment();
}
async function makeBodyParameter(stack, resolvedEnvironment, assetManifest, toolkitInfo, sdk, overrideTemplate) {
  if (stack.stackTemplateAssetObjectUrl && !overrideTemplate) {
    return {
      TemplateURL: restUrlFromManifest(
        stack.stackTemplateAssetObjectUrl,
        resolvedEnvironment,
        sdk
      )
    };
  }
  const templateJson = toYAML(overrideTemplate ?? stack.template);
  if (templateJson.length <= LARGE_TEMPLATE_SIZE_KB * 1024) {
    return { TemplateBody: templateJson };
  }
  if (!toolkitInfo.found) {
    error(
      `The template for stack "${stack.displayName}" is ${Math.round(
        templateJson.length / 1024
      )}KiB. Templates larger than ${LARGE_TEMPLATE_SIZE_KB}KiB must be uploaded to S3.
Run the following command in order to setup an S3 bucket in this environment, and then re-deploy:

`,
      blue2(`	$ cdk bootstrap ${resolvedEnvironment.name}
`)
    );
    throw new Error(
      'Template too large to deploy ("cdk bootstrap" is required)'
    );
  }
  const templateHash = contentHash(templateJson);
  const key = `cdk/${stack.id}/${templateHash}.yml`;
  let templateFile = stack.templateFile;
  if (overrideTemplate) {
    templateFile = `${stack.templateFile}-${templateHash}.yaml`;
    await fs5.writeFile(templateFile, templateJson, { encoding: "utf-8" });
  }
  assetManifest.addFileAsset(
    templateHash,
    {
      path: templateFile
    },
    {
      bucketName: toolkitInfo.bucketName,
      objectKey: key
    }
  );
  const templateURL = `${toolkitInfo.bucketUrl}/${key}`;
  debug("Storing template in S3 at:", templateURL);
  return { TemplateURL: templateURL };
}
async function makeBodyParameterAndUpload(stack, resolvedEnvironment, toolkitInfo, sdkProvider, sdk, overrideTemplate) {
  const forceUploadStack = Object.create(stack, {
    stackTemplateAssetObjectUrl: { value: void 0 }
  });
  const builder = new AssetManifestBuilder();
  const bodyparam = await makeBodyParameter(
    forceUploadStack,
    resolvedEnvironment,
    builder,
    toolkitInfo,
    sdk,
    overrideTemplate
  );
  const manifest = builder.toManifest(stack.assembly.directory);
  await publishAssets(manifest, sdkProvider, resolvedEnvironment, {
    quiet: true
  });
  return bodyparam;
}
async function destroyStack(options) {
  const deployName = options.deployName || options.stack.stackName;
  const cfn = options.sdk.cloudFormation();
  const currentStack = await CloudFormationStack.lookup(cfn, deployName);
  if (!currentStack.exists) {
    return;
  }
  try {
    await cfn.deleteStack({ StackName: deployName, RoleARN: options.roleArn }).promise();
    const destroyedStack = await waitForStackDelete(cfn, deployName);
    if (destroyedStack && destroyedStack.stackStatus.name !== "DELETE_COMPLETE") {
      throw new Error(
        `Failed to destroy ${deployName}: ${destroyedStack.stackStatus}`
      );
    }
  } catch (e) {
    throw new Error(suffixWithErrors(e.message));
  } finally {
  }
}
async function canSkipDeploy(deployStackOptions, cloudFormationStack, parameterChanges) {
  const deployName = deployStackOptions.deployName || deployStackOptions.stack.stackName;
  debug(`${deployName}: checking if we can skip deploy`);
  if (deployStackOptions.force) {
    debug(`${deployName}: forced deployment`);
    return false;
  }
  if (deployStackOptions.deploymentMethod?.method === "change-set" && deployStackOptions.deploymentMethod.execute === false) {
    debug(`${deployName}: --no-execute, always creating change set`);
    return false;
  }
  if (!cloudFormationStack.exists) {
    debug(`${deployName}: no existing stack`);
    return false;
  }
  if (cloudFormationStack.stackStatus.isInProgress) {
    debug(`${deployName}: stack is busy`);
    return false;
  }
  if (JSON.stringify(deployStackOptions.stack.template) !== JSON.stringify(await cloudFormationStack.template())) {
    debug(`${deployName}: template has changed`);
    return false;
  }
  if (!compareTags(cloudFormationStack.tags, deployStackOptions.tags ?? [])) {
    debug(`${deployName}: tags have changed`);
    return false;
  }
  if (!!deployStackOptions.stack.terminationProtection !== !!cloudFormationStack.terminationProtection) {
    debug(`${deployName}: termination protection has been updated`);
    return false;
  }
  if (parameterChanges) {
    if (parameterChanges === "ssm") {
      debug(
        `${deployName}: some parameters come from SSM so we have to assume they may have changed`
      );
    } else {
      debug(`${deployName}: parameters have changed`);
    }
    return false;
  }
  if (cloudFormationStack.stackStatus.isFailure) {
    debug(`${deployName}: stack is in a failure state`);
    return false;
  }
  return true;
}
function compareTags(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (const aTag of a) {
    const bTag = b.find((tag) => tag.Key === aTag.Key);
    if (!bTag || bTag.Value !== aTag.Value) {
      return false;
    }
  }
  return true;
}
function restUrlFromManifest(url10, environment, sdk) {
  const doNotUseMarker = "**DONOTUSE**";
  url10 = cxapi.EnvironmentPlaceholders.replace(url10, {
    accountId: environment.account,
    region: environment.region,
    partition: doNotUseMarker
  });
  if (url10.indexOf(doNotUseMarker) > -1) {
    throw new Error(
      "Cannot use '${AWS::Partition}' in the 'stackTemplateAssetObjectUrl' field"
    );
  }
  const s3Url = url10.match(/s3:\/\/([^/]+)\/(.*)$/);
  if (!s3Url) {
    return url10;
  }
  const bucketName = s3Url[1];
  const objectKey = s3Url[2];
  const urlSuffix = sdk.getEndpointSuffix(environment.region);
  return `https://s3.${environment.region}.${urlSuffix}/${bucketName}/${objectKey}`;
}
function suffixWithErrors(msg, errors) {
  return errors && errors.length > 0 ? `${msg}: ${errors.join(", ")}` : msg;
}
var LARGE_TEMPLATE_SIZE_KB, FullCloudFormationDeployment;
var init_deploy_stack = __esm({
  "src/cdk/deploy-stack.ts"() {
    "use strict";
    init_util();
    LARGE_TEMPLATE_SIZE_KB = 50;
    FullCloudFormationDeployment = class {
      constructor(options, cloudFormationStack, stackArtifact, stackParams, bodyParameter) {
        this.options = options;
        this.cloudFormationStack = cloudFormationStack;
        this.stackArtifact = stackArtifact;
        this.stackParams = stackParams;
        this.bodyParameter = bodyParameter;
        this.cfn = options.sdk.cloudFormation();
        this.stackName = options.deployName ?? stackArtifact.stackName;
        this.update = cloudFormationStack.exists && cloudFormationStack.stackStatus.name !== "REVIEW_IN_PROGRESS";
        this.verb = this.update ? "update" : "create";
        this.uuid = uuid.v4();
      }
      cfn;
      stackName;
      update;
      verb;
      uuid;
      async performDeployment() {
        const deploymentMethod = this.options.deploymentMethod ?? {
          method: "change-set"
        };
        if (deploymentMethod.method === "direct" && this.options.resourcesToImport) {
          throw new Error("Importing resources requires a changeset deployment");
        }
        switch (deploymentMethod.method) {
          case "change-set":
            return this.changeSetDeployment(deploymentMethod);
          case "direct":
            return this.directDeployment();
        }
      }
      async changeSetDeployment(deploymentMethod) {
        const changeSetName = deploymentMethod.changeSetName ?? "cdk-deploy-change-set";
        const execute = deploymentMethod.execute ?? true;
        const changeSetDescription = await this.createChangeSet(
          changeSetName,
          execute
        );
        await this.updateTerminationProtection();
        if (changeSetHasNoChanges(changeSetDescription)) {
          debug("No changes are to be performed on %s.", this.stackName);
          if (execute) {
            debug("Deleting empty change set %s", changeSetDescription.ChangeSetId);
            await this.cfn.deleteChangeSet({
              StackName: this.stackName,
              ChangeSetName: changeSetName
            }).promise();
          }
          return {
            noOp: true,
            outputs: this.cloudFormationStack.outputs,
            stackArn: changeSetDescription.StackId
          };
        }
        if (!execute) {
          print(
            "Changeset %s created and waiting in review for manual execution (--no-execute)",
            changeSetDescription.ChangeSetId
          );
          return {
            noOp: false,
            outputs: this.cloudFormationStack.outputs,
            stackArn: changeSetDescription.StackId
          };
        }
        return this.executeChangeSet(changeSetDescription);
      }
      async createChangeSet(changeSetName, willExecute) {
        await this.cleanupOldChangeset(changeSetName);
        debug(
          `Attempting to create ChangeSet with name ${changeSetName} to ${this.verb} stack ${this.stackName}`
        );
        const changeSet = await this.cfn.createChangeSet({
          StackName: this.stackName,
          ChangeSetName: changeSetName,
          ChangeSetType: this.options.resourcesToImport ? "IMPORT" : this.update ? "UPDATE" : "CREATE",
          ResourcesToImport: this.options.resourcesToImport,
          Description: `CDK Changeset for execution ${this.uuid}`,
          ClientToken: `create${this.uuid}`,
          ...this.commonPrepareOptions()
        }).promise();
        debug(
          "Initiated creation of changeset: %s; waiting for it to finish creating...",
          changeSet.Id
        );
        return waitForChangeSet(this.cfn, this.stackName, changeSetName, {
          fetchAll: willExecute
        });
      }
      async executeChangeSet(changeSet) {
        debug(
          "Initiating execution of changeset %s on stack %s",
          changeSet.ChangeSetId,
          this.stackName
        );
        await this.cfn.executeChangeSet({
          StackName: this.stackName,
          ChangeSetName: changeSet.ChangeSetName,
          ClientRequestToken: `exec${this.uuid}`,
          ...this.commonExecuteOptions()
        }).promise();
        debug(
          "Execution of changeset %s on stack %s has started; waiting for the update to complete...",
          changeSet.ChangeSetId,
          this.stackName
        );
        const changeSetLength = (changeSet.Changes ?? []).length + (this.update ? 1 : 0);
        return this.monitorDeployment(changeSet.CreationTime, changeSetLength);
      }
      async cleanupOldChangeset(changeSetName) {
        if (this.cloudFormationStack.exists) {
          debug(
            `Removing existing change set with name ${changeSetName} if it exists`
          );
          await this.cfn.deleteChangeSet({
            StackName: this.stackName,
            ChangeSetName: changeSetName
          }).promise();
        }
      }
      async updateTerminationProtection() {
        const terminationProtection = this.stackArtifact.terminationProtection ?? false;
        if (!!this.cloudFormationStack.terminationProtection !== terminationProtection) {
          debug(
            "Updating termination protection from %s to %s for stack %s",
            this.cloudFormationStack.terminationProtection,
            terminationProtection,
            this.stackName
          );
          await this.cfn.updateTerminationProtection({
            StackName: this.stackName,
            EnableTerminationProtection: terminationProtection
          }).promise();
          debug(
            "Termination protection updated to %s for stack %s",
            terminationProtection,
            this.stackName
          );
        }
      }
      async directDeployment() {
        const startTime = new Date();
        if (this.update) {
          await this.cfn.updateStack({
            StackName: this.stackName,
            ClientRequestToken: `update${this.uuid}`,
            ...this.commonPrepareOptions(),
            ...this.commonExecuteOptions()
          }).promise();
          if (this.options.noMonitor)
            return;
          const ret = await this.monitorDeployment(startTime, void 0);
          await this.updateTerminationProtection();
          return ret;
        } else {
          const terminationProtection = this.stackArtifact.terminationProtection ?? false;
          await this.cfn.createStack({
            StackName: this.stackName,
            ClientRequestToken: `create${this.uuid}`,
            ...terminationProtection ? { EnableTerminationProtection: true } : void 0,
            ...this.commonPrepareOptions(),
            ...this.commonExecuteOptions()
          }).promise();
          if (this.options.noMonitor)
            return;
          return this.monitorDeployment(startTime, void 0);
        }
      }
      async monitorDeployment(startTime, expectedChanges) {
        let finalState = this.cloudFormationStack;
        try {
          const successStack = await waitForStackDeploy(this.cfn, this.stackName);
          if (!successStack) {
            throw new Error(
              "Stack deploy failed (the stack disappeared while we were deploying it)"
            );
          }
          finalState = successStack;
        } catch (e) {
          throw new Error(suffixWithErrors(e.message));
        } finally {
        }
        debug("Stack %s has completed updating", this.stackName);
        return {
          noOp: false,
          outputs: finalState.outputs,
          stackArn: finalState.stackId
        };
      }
      commonPrepareOptions() {
        return {
          Capabilities: [
            "CAPABILITY_IAM",
            "CAPABILITY_NAMED_IAM",
            "CAPABILITY_AUTO_EXPAND"
          ],
          NotificationARNs: this.options.notificationArns,
          Parameters: this.stackParams.apiParameters,
          RoleARN: this.options.roleArn,
          TemplateBody: this.bodyParameter.TemplateBody,
          TemplateURL: this.bodyParameter.TemplateURL,
          Tags: this.options.tags
        };
      }
      commonExecuteOptions() {
        const shouldDisableRollback = this.options.rollback === false;
        return {
          StackName: this.stackName,
          ...shouldDisableRollback ? { DisableRollback: true } : void 0
        };
      }
    };
  }
});

// src/cdk/cloudformation-deployments.ts
var cloudformation_deployments_exports = {};
__export(cloudformation_deployments_exports, {
  CloudFormationDeployments: () => CloudFormationDeployments,
  prepareSdkWithLookupRoleFor: () => prepareSdkWithLookupRoleFor
});
import * as cxapi2 from "@aws-cdk/cx-api";
import { AssetManifest } from "cdk-assets";
import { debug as debug2, warning } from "sst-aws-cdk/lib/logging.js";
import {
  buildAssets,
  publishAssets as publishAssets2
} from "sst-aws-cdk/lib/util/asset-publishing.js";
import { Mode } from "sst-aws-cdk/lib/api/aws-auth/credentials.js";
import {
  loadCurrentTemplateWithNestedStacks,
  loadCurrentTemplate
} from "sst-aws-cdk/lib/api/nested-stack-helpers.js";
import { ToolkitInfo } from "sst-aws-cdk/lib/api/toolkit-info.js";
import {
  CloudFormationStack as CloudFormationStack2
} from "sst-aws-cdk/lib/api/util/cloudformation.js";
import { replaceEnvPlaceholders } from "sst-aws-cdk/lib/api/util/placeholders.js";
async function prepareSdkWithLookupRoleFor(sdkProvider, stack) {
  const resolvedEnvironment = await sdkProvider.resolveEnvironment(
    stack.environment
  );
  const arns = await replaceEnvPlaceholders(
    {
      lookupRoleArn: stack.lookupRole?.arn
    },
    resolvedEnvironment,
    sdkProvider
  );
  const warningMessage = `Could not assume ${arns.lookupRoleArn}, proceeding anyway.`;
  const upgradeMessage = `(To get rid of this warning, please upgrade to bootstrap version >= ${stack.lookupRole?.requiresBootstrapStackVersion})`;
  try {
    const stackSdk = await sdkProvider.forEnvironment(
      resolvedEnvironment,
      Mode.ForReading,
      {
        assumeRoleArn: arns.lookupRoleArn,
        assumeRoleExternalId: stack.lookupRole?.assumeRoleExternalId
      }
    );
    if (stackSdk.didAssumeRole && stack.lookupRole?.bootstrapStackVersionSsmParameter && stack.lookupRole.requiresBootstrapStackVersion) {
      const version2 = await ToolkitInfo.versionFromSsmParameter(
        stackSdk.sdk,
        stack.lookupRole.bootstrapStackVersionSsmParameter
      );
      if (version2 < stack.lookupRole.requiresBootstrapStackVersion) {
        throw new Error(
          `Bootstrap stack version '${stack.lookupRole.requiresBootstrapStackVersion}' is required, found version '${version2}'.`
        );
      }
    } else if (!stackSdk.didAssumeRole && stack.lookupRole?.requiresBootstrapStackVersion) {
      warning(upgradeMessage);
    }
    return { ...stackSdk, resolvedEnvironment };
  } catch (e) {
    debug2(e);
    if (stack.lookupRole && stack.lookupRole.requiresBootstrapStackVersion) {
      warning(warningMessage);
      warning(upgradeMessage);
    }
    throw e;
  }
}
var CloudFormationDeployments;
var init_cloudformation_deployments = __esm({
  "src/cdk/cloudformation-deployments.ts"() {
    "use strict";
    init_deploy_stack();
    init_util();
    CloudFormationDeployments = class {
      sdkProvider;
      constructor(props) {
        this.sdkProvider = props.sdkProvider;
      }
      async readCurrentTemplateWithNestedStacks(rootStackArtifact, retrieveProcessedTemplate = false) {
        const sdk = (await this.prepareSdkWithLookupOrDeployRole(rootStackArtifact)).stackSdk;
        return (await loadCurrentTemplateWithNestedStacks(
          rootStackArtifact,
          sdk,
          retrieveProcessedTemplate
        )).deployedTemplate;
      }
      async readCurrentTemplate(stackArtifact) {
        debug2(`Reading existing template for stack ${stackArtifact.displayName}.`);
        const sdk = (await this.prepareSdkWithLookupOrDeployRole(stackArtifact)).stackSdk;
        return loadCurrentTemplate(stackArtifact, sdk);
      }
      async resourceIdentifierSummaries(stackArtifact, toolkitStackName) {
        debug2(
          `Retrieving template summary for stack ${stackArtifact.displayName}.`
        );
        const { stackSdk, resolvedEnvironment } = await this.prepareSdkFor(
          stackArtifact,
          void 0,
          Mode.ForReading
        );
        const cfn = stackSdk.cloudFormation();
        const toolkitInfo = await ToolkitInfo.lookup(
          resolvedEnvironment,
          stackSdk,
          toolkitStackName
        );
        const cfnParam = await makeBodyParameterAndUpload(
          stackArtifact,
          resolvedEnvironment,
          toolkitInfo,
          this.sdkProvider,
          stackSdk
        );
        const response = await cfn.getTemplateSummary(cfnParam).promise();
        if (!response.ResourceIdentifierSummaries) {
          debug2(
            'GetTemplateSummary API call did not return "ResourceIdentifierSummaries"'
          );
        }
        return response.ResourceIdentifierSummaries ?? [];
      }
      async deployStack(options) {
        let deploymentMethod = options.deploymentMethod;
        if (options.changeSetName || options.execute !== void 0) {
          if (deploymentMethod) {
            throw new Error(
              "You cannot supply both 'deploymentMethod' and 'changeSetName/execute'. Supply one or the other."
            );
          }
          deploymentMethod = {
            method: "change-set",
            changeSetName: options.changeSetName,
            execute: options.execute
          };
        }
        const { stackSdk, resolvedEnvironment, cloudFormationRoleArn } = await this.prepareSdkFor(options.stack, options.roleArn);
        const toolkitInfo = await callWithRetry(
          () => ToolkitInfo.lookup(
            resolvedEnvironment,
            stackSdk,
            options.toolkitStackName
          )
        );
        if (options.resourcesToImport === void 0) {
          await this.publishStackAssets(options.stack, toolkitInfo, {
            buildAssets: options.buildAssets ?? true,
            publishOptions: {
              quiet: options.quiet,
              parallel: options.assetParallelism
            }
          });
        }
        await this.validateBootstrapStackVersion(
          options.stack.stackName,
          options.stack.requiresBootstrapStackVersion,
          options.stack.bootstrapStackVersionSsmParameter,
          toolkitInfo
        );
        return deployStack({
          stack: options.stack,
          noMonitor: true,
          resolvedEnvironment,
          deployName: options.deployName,
          notificationArns: options.notificationArns,
          quiet: options.quiet,
          sdk: stackSdk,
          sdkProvider: this.sdkProvider,
          roleArn: cloudFormationRoleArn,
          reuseAssets: options.reuseAssets,
          toolkitInfo,
          tags: options.tags,
          deploymentMethod,
          force: options.force,
          parameters: options.parameters,
          usePreviousParameters: options.usePreviousParameters,
          progress: options.progress,
          ci: options.ci,
          rollback: options.rollback,
          hotswap: options.hotswap,
          extraUserAgent: options.extraUserAgent,
          resourcesToImport: options.resourcesToImport,
          overrideTemplate: options.overrideTemplate,
          assetParallelism: options.assetParallelism
        });
      }
      async destroyStack(options) {
        const { stackSdk, cloudFormationRoleArn: roleArn } = await this.prepareSdkFor(options.stack, options.roleArn);
        return destroyStack({
          sdk: stackSdk,
          roleArn,
          stack: options.stack,
          deployName: options.deployName,
          quiet: options.quiet,
          ci: options.ci
        });
      }
      async stackExists(options) {
        const { stackSdk } = await this.prepareSdkFor(
          options.stack,
          void 0,
          Mode.ForReading
        );
        const stack = await CloudFormationStack2.lookup(
          stackSdk.cloudFormation(),
          options.deployName ?? options.stack.stackName
        );
        return stack.exists;
      }
      async prepareSdkWithLookupOrDeployRole(stackArtifact) {
        try {
          const result = await prepareSdkWithLookupRoleFor(
            this.sdkProvider,
            stackArtifact
          );
          if (result.didAssumeRole) {
            return {
              resolvedEnvironment: result.resolvedEnvironment,
              stackSdk: result.sdk
            };
          }
        } catch {
        }
        return this.prepareSdkFor(stackArtifact, void 0, Mode.ForReading);
      }
      async prepareSdkFor(stack, roleArn, mode = Mode.ForWriting) {
        if (!stack.environment) {
          throw new Error(
            `The stack ${stack.displayName} does not have an environment`
          );
        }
        const resolvedEnvironment = await this.sdkProvider.resolveEnvironment(
          stack.environment
        );
        const arns = await replaceEnvPlaceholders(
          {
            assumeRoleArn: stack.assumeRoleArn,
            cloudFormationRoleArn: roleArn ?? stack.cloudFormationExecutionRoleArn
          },
          resolvedEnvironment,
          this.sdkProvider
        );
        const stackSdk = await this.sdkProvider.forEnvironment(
          resolvedEnvironment,
          mode,
          {
            assumeRoleArn: arns.assumeRoleArn,
            assumeRoleExternalId: stack.assumeRoleExternalId
          }
        );
        return {
          stackSdk: stackSdk.sdk,
          resolvedEnvironment,
          cloudFormationRoleArn: arns.cloudFormationRoleArn
        };
      }
      async buildStackAssets(options) {
        const { stackSdk, resolvedEnvironment } = await this.prepareSdkFor(
          options.stack,
          options.roleArn
        );
        const toolkitInfo = await ToolkitInfo.lookup(
          resolvedEnvironment,
          stackSdk,
          options.toolkitStackName
        );
        const stackEnv = await this.sdkProvider.resolveEnvironment(
          options.stack.environment
        );
        const assetArtifacts = options.stack.dependencies.filter(
          cxapi2.AssetManifestArtifact.isAssetManifestArtifact
        );
        for (const assetArtifact of assetArtifacts) {
          await this.validateBootstrapStackVersion(
            options.stack.stackName,
            assetArtifact.requiresBootstrapStackVersion,
            assetArtifact.bootstrapStackVersionSsmParameter,
            toolkitInfo
          );
          const manifest = AssetManifest.fromFile(assetArtifact.file);
          await buildAssets(
            manifest,
            this.sdkProvider,
            stackEnv,
            options.buildOptions
          );
        }
      }
      async publishStackAssets(stack, toolkitInfo, options = {}) {
        const stackEnv = await this.sdkProvider.resolveEnvironment(
          stack.environment
        );
        const assetArtifacts = stack.dependencies.filter(
          cxapi2.AssetManifestArtifact.isAssetManifestArtifact
        );
        for (const assetArtifact of assetArtifacts) {
          await this.validateBootstrapStackVersion(
            stack.stackName,
            assetArtifact.requiresBootstrapStackVersion,
            assetArtifact.bootstrapStackVersionSsmParameter,
            toolkitInfo
          );
          const manifest = AssetManifest.fromFile(assetArtifact.file);
          await publishAssets2(manifest, this.sdkProvider, stackEnv, {
            ...options.publishOptions,
            buildAssets: options.buildAssets ?? true
          });
        }
      }
      async validateBootstrapStackVersion(stackName, requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter, toolkitInfo) {
        if (requiresBootstrapStackVersion === void 0) {
          return;
        }
        try {
          await toolkitInfo.validateVersion(
            requiresBootstrapStackVersion,
            bootstrapStackVersionSsmParameter
          );
        } catch (e) {
          throw new Error(`${stackName}: ${e.message}`);
        }
      }
    };
  }
});

// src/cdk/cloudformation-deployments-wrapper.ts
var cloudformation_deployments_wrapper_exports = {};
__export(cloudformation_deployments_wrapper_exports, {
  publishDeployAssets: () => publishDeployAssets
});
import { debug as debug3 } from "sst-aws-cdk/lib/logging.js";
import {
  CloudFormationStack as CloudFormationStack3,
  TemplateParameters as TemplateParameters2,
  waitForStackDelete as waitForStackDelete2
} from "sst-aws-cdk/lib/api/util/cloudformation.js";
import { ToolkitInfo as ToolkitInfo2 } from "sst-aws-cdk/lib/api/toolkit-info.js";
import { addMetadataAssetsToManifest as addMetadataAssetsToManifest2 } from "sst-aws-cdk/lib/assets.js";
import { publishAssets as publishAssets3 } from "sst-aws-cdk/lib/util/asset-publishing.js";
import { AssetManifestBuilder as AssetManifestBuilder2 } from "sst-aws-cdk/lib/util/asset-manifest-builder.js";
async function publishDeployAssets(sdkProvider, options) {
  const {
    deployment,
    toolkitInfo,
    stackSdk,
    resolvedEnvironment,
    cloudFormationRoleArn
  } = await useDeployment().get(sdkProvider, options);
  await deployment.publishStackAssets(options.stack, toolkitInfo, {
    buildAssets: options.buildAssets ?? true,
    publishOptions: {
      quiet: options.quiet,
      parallel: options.assetParallelism
    }
  });
  return deployStack2({
    stack: options.stack,
    noMonitor: true,
    resolvedEnvironment,
    deployName: options.deployName,
    notificationArns: options.notificationArns,
    quiet: options.quiet,
    sdk: stackSdk,
    sdkProvider,
    roleArn: cloudFormationRoleArn,
    reuseAssets: options.reuseAssets,
    toolkitInfo,
    tags: options.tags,
    deploymentMethod: options.deploymentMethod,
    force: options.force,
    parameters: options.parameters,
    usePreviousParameters: options.usePreviousParameters,
    progress: options.progress,
    ci: options.ci,
    rollback: options.rollback,
    hotswap: options.hotswap,
    extraUserAgent: options.extraUserAgent,
    resourcesToImport: options.resourcesToImport,
    overrideTemplate: options.overrideTemplate,
    assetParallelism: options.assetParallelism
  });
}
async function deployStack2(options) {
  const stackArtifact = options.stack;
  const stackEnv = options.resolvedEnvironment;
  options.sdk.appendCustomUserAgent(options.extraUserAgent);
  const cfn = options.sdk.cloudFormation();
  const deployName = options.deployName || stackArtifact.stackName;
  let cloudFormationStack = await CloudFormationStack3.lookup(cfn, deployName);
  if (cloudFormationStack.stackStatus.isCreationFailure) {
    debug3(
      `Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`
    );
    await cfn.deleteStack({ StackName: deployName }).promise();
    const deletedStack = await waitForStackDelete2(cfn, deployName);
    if (deletedStack && deletedStack.stackStatus.name !== "DELETE_COMPLETE") {
      throw new Error(
        `Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`
      );
    }
    cloudFormationStack = CloudFormationStack3.doesNotExist(cfn, deployName);
  }
  const legacyAssets = new AssetManifestBuilder2();
  const assetParams = await addMetadataAssetsToManifest2(
    stackArtifact,
    legacyAssets,
    options.toolkitInfo,
    options.reuseAssets
  );
  const finalParameterValues = { ...options.parameters, ...assetParams };
  const templateParams = TemplateParameters2.fromTemplate(
    stackArtifact.template
  );
  const stackParams = options.usePreviousParameters ? templateParams.updateExisting(
    finalParameterValues,
    cloudFormationStack.parameters
  ) : templateParams.supplyAll(finalParameterValues);
  const bodyParameter = await makeBodyParameter(
    stackArtifact,
    options.resolvedEnvironment,
    legacyAssets,
    options.toolkitInfo,
    options.sdk,
    options.overrideTemplate
  );
  await publishAssets3(
    legacyAssets.toManifest(stackArtifact.assembly.directory),
    options.sdkProvider,
    stackEnv,
    {
      parallel: options.assetParallelism
    }
  );
  return {
    isUpdate: cloudFormationStack.exists && cloudFormationStack.stackStatus.name !== "REVIEW_IN_PROGRESS",
    params: {
      StackName: deployName,
      TemplateBody: bodyParameter.TemplateBody,
      TemplateURL: bodyParameter.TemplateURL,
      Parameters: stackParams.apiParameters,
      Capabilities: [
        "CAPABILITY_IAM",
        "CAPABILITY_NAMED_IAM",
        "CAPABILITY_AUTO_EXPAND"
      ],
      Tags: options.tags
    }
  };
}
var useDeployment;
var init_cloudformation_deployments_wrapper = __esm({
  "src/cdk/cloudformation-deployments-wrapper.ts"() {
    "use strict";
    init_cloudformation_deployments();
    init_deploy_stack();
    init_context();
    useDeployment = Context.memo(() => {
      const state2 = /* @__PURE__ */ new Map();
      return {
        async get(sdkProvider, options) {
          const region = options.stack.environment.region;
          if (!state2.has(region)) {
            const deployment = new CloudFormationDeployments({ sdkProvider });
            const { stackSdk, resolvedEnvironment, cloudFormationRoleArn } = await deployment.prepareSdkFor(options.stack, options.roleArn);
            const toolkitInfo = await ToolkitInfo2.lookup(
              resolvedEnvironment,
              stackSdk,
              options.toolkitStackName
            );
            await deployment.validateBootstrapStackVersion(
              options.stack.stackName,
              options.stack.requiresBootstrapStackVersion,
              options.stack.bootstrapStackVersionSsmParameter,
              toolkitInfo
            );
            state2.set(region, {
              deployment,
              toolkitInfo,
              stackSdk,
              resolvedEnvironment,
              cloudFormationRoleArn
            });
          }
          return state2.get(region);
        }
      };
    });
  }
});

// src/stacks/deploy.ts
async function publishAssets4(stacks) {
  Logger.debug("Publishing assets");
  const provider = await useAWSProvider();
  const { publishDeployAssets: publishDeployAssets2 } = await Promise.resolve().then(() => (init_cloudformation_deployments_wrapper(), cloudformation_deployments_wrapper_exports));
  const results = {};
  for (const stack of stacks) {
    const result = await publishDeployAssets2(provider, {
      stack,
      quiet: false,
      deploymentMethod: {
        method: "direct"
      }
    });
    results[stack.stackName] = result;
  }
  return results;
}
async function deployMany(stacks) {
  if (stacks.length === 0) {
    throw new VisibleError("No stacks to deploy");
  }
  Logger.debug(
    "Deploying stacks",
    stacks.map((s) => s.stackName)
  );
  const { CloudFormationStackArtifact } = await import("aws-cdk-lib/cx-api");
  await useAWSProvider();
  const bus = useBus();
  const complete = /* @__PURE__ */ new Set();
  const todo = new Set(stacks.map((s) => s.id));
  const results = {};
  return new Promise((resolve) => {
    async function trigger() {
      for (const stack of stacks) {
        if (!todo.has(stack.id))
          continue;
        Logger.debug("Checking if", stack.id, "is ready to deploy");
        if (stack.dependencies.some(
          (dep) => dep instanceof CloudFormationStackArtifact && !complete.has(dep.id) && stacks.some((s) => s.id === dep.id)
        ))
          continue;
        deploy(stack).then((result) => {
          results[stack.id] = result;
          complete.add(stack.id);
          if (isFailed(result.status))
            stacks.forEach((s) => {
              if (todo.delete(s.stackName)) {
                complete.add(s.stackName);
                results[s.id] = {
                  status: "DEPENDENCY_FAILED",
                  outputs: {},
                  errors: {}
                };
                bus.publish("stack.status", {
                  stackID: s.id,
                  status: "DEPENDENCY_FAILED"
                });
              }
            });
          if (complete.size === stacks.length) {
            resolve(results);
          }
          trigger();
        });
        todo.delete(stack.id);
      }
    }
    trigger();
  });
}
async function deploy(stack) {
  const bus = useBus();
  Logger.debug("Deploying stack", stack.id);
  const provider = await useAWSProvider();
  const { CloudFormationDeployments: CloudFormationDeployments2 } = await Promise.resolve().then(() => (init_cloudformation_deployments(), cloudformation_deployments_exports));
  const deployment = new CloudFormationDeployments2({
    sdkProvider: provider
  });
  const stackTags = Object.entries(stack.tags ?? {}).map(([Key, Value]) => ({
    Key,
    Value
  }));
  try {
    await addInUseExports(stack);
    const result = await deployment.deployStack({
      stack,
      quiet: true,
      tags: stackTags,
      deploymentMethod: {
        method: "direct"
      }
    });
    if (result?.noOp) {
      bus.publish("stack.status", {
        stackID: stack.stackName,
        status: "SKIPPED"
      });
      return {
        errors: {},
        outputs: filterOutputs(result.outputs),
        status: "SKIPPED"
      };
    }
    bus.publish("stack.updated", {
      stackID: stack.stackName
    });
    return monitor(stack.stackName);
  } catch (ex) {
    Logger.debug("Failed to deploy stack", stack.id, ex);
    if (ex.message === "No updates are to be performed.") {
      return monitor(stack.stackName);
    }
    bus.publish("stack.status", {
      stackID: stack.stackName,
      status: "UPDATE_FAILED"
    });
    return {
      errors: {
        stack: ex.message
      },
      outputs: {},
      status: "UPDATE_FAILED"
    };
  }
}
async function addInUseExports(stack) {
  const oldOutputs = await getCloudFormationStackOutputs(stack);
  if (!oldOutputs)
    return;
  const newTemplate = JSON.parse(await getLocalTemplate(stack));
  const newOutputs = newTemplate.Outputs || {};
  const newExportNames = Object.keys(newOutputs).filter((outputKey) => outputKey.startsWith("ExportsOutput")).filter((outputKey) => newOutputs[outputKey].Export).map((outputKey) => newOutputs[outputKey].Export.Name);
  let isDirty = false;
  await Promise.all(
    oldOutputs.filter((output) => output.OutputKey?.startsWith("ExportsOutput")).filter((output) => output.ExportName).filter((output) => !newExportNames.includes(output.ExportName)).map(async (output) => {
      const imports = await listImports(output.ExportName);
      if (imports.length > 0) {
        Logger.debug(
          `deploy stack: addInUseExports: export ${output.ExportName} used in ${imports.join(", ")}`
        );
        newTemplate.Outputs = newTemplate.Outputs || {};
        newTemplate.Outputs[output.OutputKey] = {
          Description: `Output added by SST b/c exported value still used in ${imports.join(
            ", "
          )}`,
          Value: output.OutputValue,
          Export: {
            Name: output.ExportName
          }
        };
        isDirty = true;
      }
    })
  );
  if (isDirty) {
    await saveLocalTemplate(stack, JSON.stringify(newTemplate, null, 2));
  }
}
async function getCloudFormationStackOutputs(stack) {
  const { CloudFormationClient: CloudFormationClient4, DescribeStacksCommand: DescribeStacksCommand3 } = await import("@aws-sdk/client-cloudformation");
  const client = useAWSClient(CloudFormationClient4);
  try {
    const { Stacks: stacks } = await client.send(
      new DescribeStacksCommand3({
        StackName: stack.id
      })
    );
    if (!stacks || stacks.length === 0)
      return;
    return stacks[0].Outputs || [];
  } catch (e) {
    if (e.name === "ValidationError" && e.message.includes("Stack with id") && e.message.includes("does not exist")) {
      return;
    } else {
      throw e;
    }
  }
}
async function listImports(exportName) {
  const { CloudFormationClient: CloudFormationClient4, ListImportsCommand } = await import("@aws-sdk/client-cloudformation");
  const client = useAWSClient(CloudFormationClient4);
  try {
    const ret = await client.send(
      new ListImportsCommand({
        ExportName: exportName
      })
    );
    return ret.Imports || [];
  } catch (e) {
    if (e.name === "ValidationError" && e.message.includes("is not imported by any stack")) {
      return [];
    }
    throw e;
  }
}
async function getLocalTemplate(stack) {
  const fs18 = await import("fs/promises");
  const fileContent = await fs18.readFile(stack.templateFullPath);
  return fileContent.toString();
}
async function saveLocalTemplate(stack, content) {
  const fs18 = await import("fs/promises");
  await fs18.writeFile(stack.templateFullPath, content);
}
var init_deploy = __esm({
  "src/stacks/deploy.ts"() {
    "use strict";
    init_bus();
    init_credentials();
    init_logger();
    init_monitor();
    init_error();
  }
});

// src/stacks/diff.ts
async function diff(stack, oldTemplate) {
  const { diffTemplate, formatDifferences, TemplateDiff } = await import("@aws-cdk/cloudformation-diff");
  const diff3 = diffTemplate(oldTemplate, stack.template);
  if (diff3.isEmpty) {
    return { count: 0 };
  }
  diff3.iamChanges = { hasChanges: false };
  diff3.securityGroupChanges = { hasChanges: false };
  diff3.awsTemplateFormatVersion = false;
  diff3.transform = false;
  diff3.description = false;
  diff3.parameters = { differenceCount: 0 };
  diff3.metadata = { differenceCount: 0 };
  diff3.mappings = { differenceCount: 0 };
  diff3.conditions = { differenceCount: 0 };
  diff3.unknown = { differenceCount: 0 };
  delete diff3.outputs.diffs?.["SSTMetadata"];
  const output = [];
  const stream = {
    write(chunk) {
      output.push(`   ${chunk}`);
    }
  };
  const pathMap = await buildLogicalToPathMap(stack);
  formatDifferences(stream, diff3, pathMap);
  while (true) {
    if (output[output.length - 1]?.match(/^\s*$/)) {
      output.pop();
    } else {
      break;
    }
  }
  return {
    count: diff3.outputs.differenceCount + diff3.resources.differenceCount,
    diff: output.join("")
  };
}
async function buildLogicalToPathMap(stack) {
  const { ArtifactMetadataEntryType } = await import("@aws-cdk/cloud-assembly-schema");
  const map3 = {};
  for (const md of stack.findMetadataByType(
    ArtifactMetadataEntryType.LOGICAL_ID
  )) {
    map3[md.data] = md.path;
  }
  return map3;
}
var init_diff = __esm({
  "src/stacks/diff.ts"() {
    "use strict";
  }
});

// src/cache.ts
import path5 from "path";
import fs6 from "fs/promises";
var useCache;
var init_cache = __esm({
  "src/cache.ts"() {
    "use strict";
    init_project();
    init_logger();
    init_context();
    useCache = Context.memo(async () => {
      const project = useProject();
      const cache = path5.join(project.paths.out, "cache");
      await fs6.mkdir(cache, {
        recursive: true
      });
      async function write(key, data2) {
        const full = path5.join(cache, key);
        Logger.debug("Writing cache", full, data2.length, "bytes");
        await fs6.writeFile(full, data2);
      }
      async function read(key) {
        const full = path5.join(cache, key);
        try {
          const data2 = await fs6.readFile(full);
          return data2.toString();
        } catch {
          return null;
        }
      }
      return {
        write,
        read
      };
    });
  }
});

// src/stacks/metadata.ts
var metadata_exports = {};
__export(metadata_exports, {
  metadata: () => metadata2,
  useMetadata: () => useMetadata
});
import {
  S3Client as S3Client2,
  GetObjectCommand as GetObjectCommand2,
  ListObjectsV2Command
} from "@aws-sdk/client-s3";
async function metadata2() {
  Logger.debug("Fetching all metadata");
  const project = useProject();
  const [credentials, bootstrap2] = await Promise.all([
    useAWSCredentials(),
    useBootstrap()
  ]);
  const s3 = new S3Client2({
    region: project.config.region,
    credentials
  });
  const key = `stackMetadata/app.${project.config.name}/stage.${project.config.stage}/`;
  const list2 = await s3.send(
    new ListObjectsV2Command({
      Prefix: key,
      Bucket: bootstrap2.bucket
    })
  );
  const result = Object.fromEntries(
    await Promise.all(
      list2.Contents?.map(async (obj) => {
        const stackID = obj.Key?.split("/").pop();
        const result2 = await s3.send(
          new GetObjectCommand2({
            Key: obj.Key,
            Bucket: bootstrap2.bucket
          })
        );
        const body = await result2.Body.transformToString();
        return [stackID, JSON.parse(body)];
      }) || []
    )
  );
  Logger.debug("Fetched metadata from", list2.KeyCount, "stacks");
  return result;
}
var MetadataContext2, useMetadata;
var init_metadata = __esm({
  "src/stacks/metadata.ts"() {
    "use strict";
    init_bootstrap();
    init_credentials();
    init_cache();
    init_context();
    init_bus();
    init_logger();
    init_project();
    MetadataContext2 = Context.create(async () => {
      const bus = useBus();
      const cache = await useCache();
      const data2 = await metadata2();
      bus.publish("stacks.metadata", data2);
      bus.subscribe("stacks.metadata.updated", async () => {
        const data3 = await metadata2();
        await cache.write(`metadata.json`, JSON.stringify(data3));
        bus.publish("stacks.metadata", data3);
        MetadataContext2.provide(Promise.resolve(data3));
      });
      bus.subscribe("stacks.metadata.deleted", async () => {
        const data3 = await metadata2();
        await cache.write(`metadata.json`, JSON.stringify(data3));
        bus.publish("stacks.metadata", data3);
        MetadataContext2.provide(Promise.resolve(data3));
      });
      return data2;
    });
    useMetadata = MetadataContext2.use;
  }
});

// src/watcher.ts
var watcher_exports = {};
__export(watcher_exports, {
  useWatcher: () => useWatcher
});
import chokidar from "chokidar";
import path6 from "path";
var useWatcher;
var init_watcher = __esm({
  "src/watcher.ts"() {
    "use strict";
    init_context();
    init_bus();
    init_project();
    useWatcher = Context.memo(() => {
      const project = useProject();
      const bus = useBus();
      const watcher = chokidar.watch([project.paths.root], {
        persistent: true,
        ignoreInitial: true,
        followSymlinks: false,
        disableGlobbing: false,
        ignored: [
          "**/node_modules/**",
          "**/.build/**",
          "**/.sst/**",
          "**/.git/**",
          "**/debug.log"
        ],
        awaitWriteFinish: {
          pollInterval: 100,
          stabilityThreshold: 20
        }
      });
      watcher.on("change", (file) => {
        bus.publish("file.changed", {
          file,
          relative: path6.relative(project.paths.root, file)
        });
      });
      return {
        subscribe: bus.forward("file.changed")
      };
    });
  }
});

// src/runtime/handlers.ts
import path7 from "path";
import fs7 from "fs/promises";
import { useFunctions } from "../src/constructs/Function.js";
var useRuntimeHandlers, useFunctionBuilder;
var init_handlers = __esm({
  "src/runtime/handlers.ts"() {
    "use strict";
    init_context();
    init_logger();
    init_watcher();
    init_bus();
    init_project();
    useRuntimeHandlers = Context.memo(() => {
      const handlers = [];
      const project = useProject();
      const bus = useBus();
      const pendingBuilds = /* @__PURE__ */ new Map();
      const result = {
        subscribe: bus.forward("function.build.success", "function.build.failed"),
        register: (handler) => {
          handlers.push(handler);
        },
        for: (runtime) => {
          const result2 = handlers.find((x) => x.canHandle(runtime));
          if (!result2)
            throw new Error(`${runtime} runtime is unsupported`);
          return result2;
        },
        async build(functionID, mode) {
          async function task() {
            const func = useFunctions().fromID(functionID);
            if (!func)
              return {
                type: "error",
                errors: [`Function with ID "${functionID}" not found`]
              };
            const handler = result.for(func.runtime);
            const out = path7.join(project.paths.artifacts, functionID);
            await fs7.rm(out, { recursive: true, force: true });
            await fs7.mkdir(out, { recursive: true });
            if (func.hooks?.beforeBuild)
              await func.hooks.beforeBuild(func, out);
            const built = await handler.build({
              functionID,
              out,
              mode,
              props: func
            });
            if (built.type === "error") {
              bus.publish("function.build.failed", {
                functionID,
                errors: built.errors
              });
              return built;
            }
            if (func.copyFiles) {
              await Promise.all(
                func.copyFiles.map(async (entry) => {
                  const fromPath = path7.join(project.paths.root, entry.from);
                  const to = entry.to || entry.from;
                  if (path7.isAbsolute(to))
                    throw new Error(
                      `Copy destination path "${to}" must be relative`
                    );
                  const toPath = path7.join(out, to);
                  if (mode === "deploy")
                    await fs7.cp(fromPath, toPath, {
                      recursive: true
                    });
                  if (mode === "start") {
                    try {
                      const dir = path7.dirname(toPath);
                      await fs7.mkdir(dir, { recursive: true });
                      await fs7.symlink(fromPath, toPath);
                    } catch (ex) {
                      Logger.debug("Failed to symlink", fromPath, toPath, ex);
                    }
                  }
                })
              );
            }
            if (func.hooks?.afterBuild)
              await func.hooks.afterBuild(func, out);
            bus.publish("function.build.success", { functionID });
            return {
              ...built,
              out
            };
          }
          if (pendingBuilds.has(functionID)) {
            Logger.debug("Waiting on pending build", functionID);
            return pendingBuilds.get(functionID);
          }
          const promise = task();
          pendingBuilds.set(functionID, promise);
          Logger.debug("Building function", functionID);
          const r = await promise;
          pendingBuilds.delete(functionID);
          return r;
        }
      };
      return result;
    });
    useFunctionBuilder = Context.memo(() => {
      const artifacts = /* @__PURE__ */ new Map();
      const handlers = useRuntimeHandlers();
      const result = {
        artifact: (functionID) => {
          if (artifacts.has(functionID))
            return artifacts.get(functionID);
          return result.build(functionID);
        },
        build: async (functionID) => {
          const result2 = await handlers.build(functionID, "start");
          if (!result2)
            return;
          if (result2.type === "error")
            return;
          artifacts.set(functionID, result2);
          return artifacts.get(functionID);
        }
      };
      const watcher = useWatcher();
      watcher.subscribe("file.changed", async (evt) => {
        try {
          const functions = useFunctions();
          for (const [functionID, props] of Object.entries(functions.all)) {
            const handler = handlers.for(props.runtime);
            if (!handler?.shouldBuild({
              functionID,
              file: evt.properties.file
            }))
              continue;
            await result.build(functionID);
            Logger.debug("Rebuilt function", functionID);
          }
        } catch {
        }
      });
      return result;
    });
  }
});

// src/runtime/server.ts
var server_exports = {};
__export(server_exports, {
  useRuntimeServer: () => useRuntimeServer,
  useRuntimeServerConfig: () => useRuntimeServerConfig
});
import express from "express";
import https2 from "https";
import getPort from "get-port";
var useRuntimeServerConfig, useRuntimeServer;
var init_server = __esm({
  "src/runtime/server.ts"() {
    "use strict";
    init_context();
    init_bus();
    init_logger();
    init_workers();
    useRuntimeServerConfig = Context.memo(async () => {
      const port = await getPort({
        port: 12557
      });
      return {
        API_VERSION: "2018-06-01",
        port,
        url: `http://localhost:${port}`
      };
    });
    useRuntimeServer = Context.memo(async () => {
      const bus = useBus();
      const app = express();
      const workers = await useRuntimeWorkers();
      const cfg = await useRuntimeServerConfig();
      const workersWaiting = /* @__PURE__ */ new Map();
      const invocationsQueued = /* @__PURE__ */ new Map();
      function next(workerID) {
        const queue = invocationsQueued.get(workerID);
        const value = queue?.shift();
        if (value)
          return value;
        return new Promise((resolve, reject) => {
          workersWaiting.set(workerID, resolve);
        });
      }
      workers.subscribe("worker.exited", async (evt) => {
        const waiting = workersWaiting.get(evt.properties.workerID);
        if (!waiting)
          return;
        workersWaiting.delete(evt.properties.workerID);
      });
      bus.subscribe("function.invoked", async (evt) => {
        const worker = workersWaiting.get(evt.properties.workerID);
        if (worker) {
          workersWaiting.delete(evt.properties.workerID);
          worker(evt.properties);
          return;
        }
        let arr = invocationsQueued.get(evt.properties.workerID);
        if (!arr) {
          arr = [];
          invocationsQueued.set(evt.properties.workerID, arr);
        }
        arr.push(evt.properties);
      });
      app.post(
        `/:workerID/${cfg.API_VERSION}/runtime/init/error`,
        express.json({
          strict: false,
          type: ["application/json", "application/*+json"],
          limit: "10mb"
        }),
        async (req, res) => {
          const worker = workers.fromID(req.params.workerID);
          bus.publish("function.error", {
            requestID: workers.getCurrentRequestID(worker.workerID),
            workerID: worker.workerID,
            functionID: worker.functionID,
            ...req.body
          });
          res.json("ok");
        }
      );
      app.get(
        `/:workerID/${cfg.API_VERSION}/runtime/invocation/next`,
        async (req, res) => {
          Logger.debug(
            "Worker",
            req.params.workerID,
            "is waiting for next invocation"
          );
          const payload = await next(req.params.workerID);
          Logger.debug("Worker", req.params.workerID, "sending next payload");
          res.set({
            "Lambda-Runtime-Aws-Request-Id": payload.context.awsRequestId,
            "Lambda-Runtime-Deadline-Ms": Date.now() + payload.deadline,
            "Lambda-Runtime-Invoked-Function-Arn": payload.context.invokedFunctionArn,
            "Lambda-Runtime-Client-Context": JSON.stringify(
              payload.context.clientContext || null
            ),
            "Lambda-Runtime-Cognito-Identity": JSON.stringify(
              payload.context.identity || null
            ),
            "Lambda-Runtime-Log-Group-Name": payload.context.logGroupName,
            "Lambda-Runtime-Log-Stream-Name": payload.context.logStreamName
          });
          res.json(payload.event);
        }
      );
      app.post(
        `/:workerID/${cfg.API_VERSION}/runtime/invocation/:awsRequestId/response`,
        express.json({
          strict: false,
          type() {
            return true;
          },
          limit: "10mb"
        }),
        (req, res) => {
          Logger.debug("Worker", req.params.workerID, "got response", req.body);
          const worker = workers.fromID(req.params.workerID);
          bus.publish("function.success", {
            workerID: worker.workerID,
            functionID: worker.functionID,
            requestID: req.params.awsRequestId,
            body: req.body
          });
          res.status(202).send();
        }
      );
      app.all(
        `/proxy*`,
        express.raw({
          type: "*/*",
          limit: "1024mb"
        }),
        (req, res) => {
          res.header("Access-Control-Allow-Origin", "*");
          res.header(
            "Access-Control-Allow-Methods",
            "GET, PUT, PATCH, POST, DELETE"
          );
          res.header(
            "Access-Control-Allow-Headers",
            req.header("access-control-request-headers")
          );
          if (req.method === "OPTIONS")
            return res.send();
          const u = new URL(req.url.substring(7));
          const forward = https2.request(
            u,
            {
              headers: {
                ...req.headers,
                host: u.hostname
              },
              method: req.method
            },
            (proxied) => {
              res.status(proxied.statusCode);
              for (const [key, value] of Object.entries(proxied.headers)) {
                res.header(key, value);
              }
              proxied.pipe(res);
            }
          );
          if (req.method !== "GET" && req.method !== "DELETE" && req.method !== "HEAD" && req.body)
            forward.write(req.body);
          forward.end();
          forward.on("error", (e) => {
            console.log(e.message);
          });
        }
      );
      app.post(
        `/:workerID/${cfg.API_VERSION}/runtime/invocation/:awsRequestId/error`,
        express.json({
          strict: false,
          type: ["application/json", "application/*+json"],
          limit: "10mb"
        }),
        (req, res) => {
          const worker = workers.fromID(req.params.workerID);
          bus.publish("function.error", {
            workerID: worker.workerID,
            functionID: worker.functionID,
            errorType: req.body.errorType,
            errorMessage: req.body.errorMessage,
            requestID: req.params.awsRequestId,
            trace: req.body.trace
          });
          res.status(202).send();
        }
      );
      app.listen(cfg.port);
    });
  }
});

// src/runtime/workers.ts
var workers_exports = {};
__export(workers_exports, {
  useRuntimeWorkers: () => useRuntimeWorkers
});
import { useFunctions as useFunctions2 } from "../src/constructs/Function.js";
var useRuntimeWorkers;
var init_workers = __esm({
  "src/runtime/workers.ts"() {
    "use strict";
    init_context();
    init_bus();
    init_handlers();
    init_server();
    useRuntimeWorkers = Context.memo(async () => {
      const workers = /* @__PURE__ */ new Map();
      const bus = useBus();
      const handlers = useRuntimeHandlers();
      const builder = useFunctionBuilder();
      const server = await useRuntimeServerConfig();
      handlers.subscribe("function.build.success", async (evt) => {
        for (const [_, worker] of workers) {
          if (worker.functionID === evt.properties.functionID) {
            const props = useFunctions2().fromID(worker.functionID);
            if (!props)
              return;
            const handler = handlers.for(props.runtime);
            await handler?.stopWorker(worker.workerID);
            bus.publish("worker.stopped", worker);
          }
        }
      });
      const lastRequestId = /* @__PURE__ */ new Map();
      bus.subscribe("function.invoked", async (evt) => {
        bus.publish("function.ack", {
          functionID: evt.properties.functionID,
          workerID: evt.properties.workerID
        });
        lastRequestId.set(evt.properties.workerID, evt.properties.requestID);
        let worker = workers.get(evt.properties.workerID);
        if (worker)
          return;
        const props = useFunctions2().fromID(evt.properties.functionID);
        if (!props)
          return;
        const handler = handlers.for(props.runtime);
        if (!handler)
          return;
        const build2 = await builder.artifact(evt.properties.functionID);
        if (!build2)
          return;
        await handler.startWorker({
          ...build2,
          workerID: evt.properties.workerID,
          environment: evt.properties.env,
          url: `${server.url}/${evt.properties.workerID}/${server.API_VERSION}`
        });
        workers.set(evt.properties.workerID, {
          workerID: evt.properties.workerID,
          functionID: evt.properties.functionID
        });
        bus.publish("worker.started", {
          workerID: evt.properties.workerID,
          functionID: evt.properties.functionID
        });
      });
      return {
        fromID(workerID) {
          return workers.get(workerID);
        },
        getCurrentRequestID(workerID) {
          return lastRequestId.get(workerID);
        },
        stdout(workerID, message) {
          const worker = workers.get(workerID);
          bus.publish("worker.stdout", {
            ...worker,
            message: message.trim(),
            requestID: lastRequestId.get(workerID)
          });
        },
        exited(workerID) {
          const existing = workers.get(workerID);
          if (!existing)
            return;
          workers.delete(workerID);
          lastRequestId.delete(workerID);
          bus.publish("worker.exited", existing);
        },
        subscribe: bus.forward(
          "worker.started",
          "worker.stopped",
          "worker.exited",
          "worker.stdout"
        )
      };
    });
  }
});

// src/util/process.ts
import { exec } from "child_process";
import { promisify } from "util";
var execAsync;
var init_process = __esm({
  "src/util/process.ts"() {
    "use strict";
    execAsync = promisify(exec);
  }
});

// src/runtime/handlers/dotnet.ts
import { spawn } from "child_process";
import url3 from "url";
var FRAMEWORK_MAP, BOOTSTRAP_MAP, useDotnetHandler;
var init_dotnet = __esm({
  "src/runtime/handlers/dotnet.ts"() {
    "use strict";
    init_handlers();
    init_workers();
    init_context();
    init_server();
    init_fs();
    init_project();
    init_process();
    FRAMEWORK_MAP = {
      "dotnetcore1.0": "netcoreapp3.1",
      "dotnetcore2.0": "netcoreapp3.1",
      "dotnetcore2.1": "netcoreapp3.1",
      "dotnetcore3.1": "netcoreapp3.1",
      dotnet6: "net6.0"
    };
    BOOTSTRAP_MAP = {
      "dotnetcore1.0": "dotnet31-bootstrap",
      "dotnetcore2.0": "dotnet31-bootstrap",
      "dotnetcore2.1": "dotnet31-bootstrap",
      "dotnetcore3.1": "dotnet31-bootstrap",
      dotnet6: "dotnet6-bootstrap"
    };
    useDotnetHandler = Context.memo(async () => {
      const workers = await useRuntimeWorkers();
      const server = await useRuntimeServerConfig();
      const handlers = useRuntimeHandlers();
      const processes = /* @__PURE__ */ new Map();
      const sources = /* @__PURE__ */ new Map();
      const handlerName = process.platform === "win32" ? `handler.exe` : `handler`;
      handlers.register({
        shouldBuild: (input) => {
          if (!input.file.endsWith(".cs") && !input.file.endsWith(".fs"))
            return false;
          const parent = sources.get(input.functionID);
          if (!parent)
            return false;
          return isChild(parent, input.file);
        },
        canHandle: (input) => input.startsWith("dotnet"),
        startWorker: async (input) => {
          const name = input.handler.split(":")[0];
          const proc = spawn(
            `dotnet`,
            [
              `exec`,
              url3.fileURLToPath(
                new URL(
                  `../../support/${BOOTSTRAP_MAP["dotnetcore3.1"]}/release/dotnet-bootstrap.dll`,
                  import.meta.url
                )
              ),
              name + ".dll",
              input.handler
            ],
            {
              env: {
                ...process.env,
                ...input.environment,
                IS_LOCAL: "true",
                AWS_LAMBDA_RUNTIME_API: `localhost:${server.port}/${input.workerID}`,
                AWS_LAMBDA_DOTNET_DEBUG_RUN_ONCE: "true"
              },
              cwd: input.out
            }
          );
          proc.on("exit", () => workers.exited(input.workerID));
          proc.stdout.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          proc.stderr.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          processes.set(input.workerID, proc);
        },
        stopWorker: async (workerID) => {
          const proc = processes.get(workerID);
          if (proc) {
            proc.kill();
            processes.delete(workerID);
          }
        },
        build: async (input) => {
          const project = useProject();
          const name = input.props.handler.split(":")[0];
          const srcPath = await findBelow(project.paths.root, `${name}.csproj`);
          sources.set(input.functionID, srcPath);
          try {
            await execAsync(
              [
                "dotnet",
                "publish",
                "--output",
                input.out,
                "--configuration",
                "Release",
                "--framework",
                FRAMEWORK_MAP[input.props.runtime],
                "/p:GenerateRuntimeConfigurationFiles=true",
                "/clp:ForceConsoleColor",
                "--self-contained",
                "false",
                "-nologo"
              ].join(" "),
              {
                cwd: srcPath
              }
            );
            return {
              type: "success",
              handler: input.props.handler
            };
          } catch (ex) {
            return {
              type: "error",
              errors: [ex.stderr]
            };
          }
        }
      });
    });
  }
});

// src/runtime/handlers/node.ts
var node_exports = {};
__export(node_exports, {
  useNodeHandler: () => useNodeHandler
});
import path8 from "path";
import fs8 from "fs/promises";
import { exec as exec2 } from "child_process";
import fsSync2 from "fs";
import esbuild2 from "esbuild";
import url4 from "url";
import { Worker } from "worker_threads";
var useNodeHandler;
var init_node = __esm({
  "src/runtime/handlers/node.ts"() {
    "use strict";
    init_project();
    init_handlers();
    init_workers();
    init_context();
    init_error();
    init_colors();
    useNodeHandler = Context.memo(async () => {
      const workers = await useRuntimeWorkers();
      const handlers = useRuntimeHandlers();
      const cache = {};
      const project = useProject();
      const threads = /* @__PURE__ */ new Map();
      handlers.register({
        shouldBuild: (input) => {
          const result = cache[input.functionID];
          if (!result)
            return false;
          const relative = path8.relative(project.paths.root, input.file).split(path8.sep).join(path8.posix.sep);
          return Boolean(result.metafile?.inputs[relative]);
        },
        canHandle: (input) => input.startsWith("nodejs"),
        startWorker: async (input) => {
          new Promise(async () => {
            const worker = new Worker(
              url4.fileURLToPath(
                new URL("../../support/nodejs-runtime/index.mjs", import.meta.url)
              ),
              {
                env: {
                  ...input.environment,
                  IS_LOCAL: "true"
                },
                execArgv: ["--enable-source-maps"],
                workerData: input,
                stderr: true,
                stdin: true,
                stdout: true
              }
            );
            worker.stdout.on("data", (data2) => {
              workers.stdout(input.workerID, data2.toString());
            });
            worker.stderr.on("data", (data2) => {
              workers.stdout(input.workerID, data2.toString());
            });
            worker.on("exit", () => workers.exited(input.workerID));
            threads.set(input.workerID, worker);
          });
        },
        stopWorker: async (workerID) => {
          const worker = threads.get(workerID);
          await worker?.terminate();
        },
        build: async (input) => {
          const exists = cache[input.functionID];
          const parsed = path8.parse(input.props.handler);
          const file = [
            ".ts",
            ".tsx",
            ".mts",
            ".cts",
            ".js",
            ".jsx",
            ".mjs",
            ".cjs"
          ].map((ext) => path8.join(parsed.dir, parsed.name + ext)).find((file2) => {
            return fsSync2.existsSync(file2);
          });
          if (!file)
            return {
              type: "error",
              errors: [`Could not find file for handler "${input.props.handler}"`]
            };
          const nodejs = input.props.nodejs || {};
          const isESM = (nodejs.format || "esm") === "esm";
          const relative = path8.relative(
            project.paths.root,
            path8.resolve(parsed.dir)
          );
          const extension = isESM ? ".mjs" : ".cjs";
          const target = path8.join(
            input.out,
            !relative.startsWith("..") && !path8.isAbsolute(input.props.handler) ? relative : "",
            parsed.name + extension
          );
          const handler = path8.relative(input.out, target.replace(extension, parsed.ext)).split(path8.sep).join(path8.posix.sep);
          if (exists?.rebuild) {
            const result = await exists.rebuild();
            cache[input.functionID] = result;
            return {
              type: "success",
              handler
            };
          }
          const { external, ...override } = nodejs.esbuild || {};
          const forceExternal = [
            "sharp",
            "pg-native",
            ...isESM || input.props.runtime === "nodejs18.x" ? [] : ["aws-sdk"]
          ];
          const options = {
            entryPoints: [file],
            platform: "node",
            external: [
              ...forceExternal,
              ...nodejs.install || [],
              ...external || []
            ],
            loader: nodejs.loader,
            keepNames: true,
            bundle: true,
            logLevel: "silent",
            metafile: true,
            ...isESM ? {
              format: "esm",
              target: "esnext",
              mainFields: ["module", "main"],
              banner: {
                js: [
                  `import { createRequire as topLevelCreateRequire } from 'module';`,
                  `const require = topLevelCreateRequire(import.meta.url);`,
                  `import { fileURLToPath as topLevelFileUrlToPath, URL as topLevelURL } from "url"`,
                  `const __dirname = topLevelFileUrlToPath(new topLevelURL(".", import.meta.url))`,
                  nodejs.banner || ""
                ].join("\n")
              }
            } : {
              format: "cjs",
              target: "node14",
              banner: nodejs.banner ? {
                js: nodejs.banner
              } : void 0
            },
            outfile: target,
            sourcemap: input.mode === "start" ? "linked" : nodejs.sourcemap,
            minify: nodejs.minify,
            ...override
          };
          try {
            const result = await esbuild2.build(options);
            const installPackages = [
              ...nodejs.install || [],
              ...forceExternal.filter((pkg) => pkg !== "aws-sdk").filter((pkg) => !external?.includes(pkg)).filter(
                (pkg) => Object.values(result.metafile?.inputs || {}).some(
                  ({ imports }) => imports.some(({ path: path20 }) => path20 === pkg)
                )
              )
            ];
            const warnings = [];
            Object.entries(result.metafile?.inputs || {}).forEach(
              ([inputPath, { imports }]) => imports.filter(({ path: path20 }) => path20.includes("sst/constructs")).forEach(({ path: path20 }) => {
                warnings.push(
                  `You are importing from "${path20}" in "${inputPath}". Did you mean to import from "sst/node"?`
                );
              })
            );
            async function find2(dir, target2) {
              if (dir === "/")
                throw new VisibleError("Could not find a package.json file");
              if (await fs8.access(path8.join(dir, target2)).then(() => true).catch(() => false))
                return dir;
              return find2(path8.join(dir, ".."), target2);
            }
            if (input.mode === "deploy" && installPackages) {
              const src = await find2(parsed.dir, "package.json");
              const json = JSON.parse(
                await fs8.readFile(path8.join(src, "package.json")).then((x) => x.toString())
              );
              fs8.writeFile(
                path8.join(input.out, "package.json"),
                JSON.stringify({
                  dependencies: Object.fromEntries(
                    installPackages.map((x) => [x, json.dependencies?.[x] || "*"])
                  )
                })
              );
              const cmd = ["npm install"];
              if (installPackages.includes("sharp")) {
                cmd.push(
                  "--platform=linux",
                  input.props.architecture === "arm_64" ? "--arch=arm64" : "--arch=x64"
                );
              }
              await new Promise((resolve) => {
                const process2 = exec2(cmd.join(" "), {
                  cwd: input.out
                });
                process2.on("exit", () => resolve());
              });
            }
            if (input.mode === "start") {
              const dir = path8.join(
                await find2(parsed.dir, "package.json"),
                "node_modules"
              );
              try {
                await fs8.symlink(
                  path8.resolve(dir),
                  path8.resolve(path8.join(input.out, "node_modules")),
                  "dir"
                );
              } catch {
              }
            }
            cache[input.functionID] = result;
            return {
              type: "success",
              handler
            };
          } catch (ex) {
            const result = ex;
            if ("errors" in result) {
              return {
                type: "error",
                errors: result.errors.flatMap((x) => [
                  Colors.bold(x.text),
                  x.location?.file || "",
                  Colors.dim(x.location?.line, "\u2502", x.location?.lineText)
                ])
              };
            }
            return {
              type: "error",
              errors: [ex.toString()]
            };
          }
        }
      });
    });
  }
});

// src/runtime/handlers/go.ts
var go_exports = {};
__export(go_exports, {
  useGoHandler: () => useGoHandler
});
import path9 from "path";
import fs9 from "fs/promises";
import os3 from "os";
import { spawn as spawn2 } from "child_process";
async function find(dir, target) {
  if (dir === "/")
    throw new VisibleError(`Could not find a ${target} file`);
  if (await fs9.access(path9.join(dir, target)).then(() => true).catch(() => false))
    return dir;
  return find(path9.join(dir, ".."), target);
}
var useGoHandler;
var init_go = __esm({
  "src/runtime/handlers/go.ts"() {
    "use strict";
    init_handlers();
    init_workers();
    init_context();
    init_error();
    init_server();
    init_fs();
    init_process();
    useGoHandler = Context.memo(async () => {
      const workers = await useRuntimeWorkers();
      const server = await useRuntimeServerConfig();
      const handlers = useRuntimeHandlers();
      const processes = /* @__PURE__ */ new Map();
      const sources = /* @__PURE__ */ new Map();
      const handlerName = process.platform === "win32" ? `bootstrap.exe` : `bootstrap`;
      handlers.register({
        shouldBuild: (input) => {
          const parent = sources.get(input.functionID);
          if (!parent)
            return false;
          return isChild(parent, input.file);
        },
        canHandle: (input) => input.startsWith("go"),
        startWorker: async (input) => {
          const proc = spawn2(path9.join(input.out, handlerName), {
            env: {
              ...process.env,
              ...input.environment,
              IS_LOCAL: "true",
              AWS_LAMBDA_RUNTIME_API: `localhost:${server.port}/${input.workerID}`
            },
            cwd: input.out
          });
          proc.on("exit", () => workers.exited(input.workerID));
          proc.stdout.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          proc.stderr.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          processes.set(input.workerID, proc);
        },
        stopWorker: async (workerID) => {
          const proc = processes.get(workerID);
          if (proc) {
            proc.kill();
            processes.delete(workerID);
          }
        },
        build: async (input) => {
          const parsed = path9.parse(input.props.handler);
          const project = await find(parsed.dir, "go.mod");
          sources.set(input.functionID, project);
          const src = path9.relative(project, input.props.handler);
          if (input.mode === "start") {
            try {
              const target = path9.join(input.out, handlerName);
              const srcPath = os3.platform() === "win32" ? src.replaceAll("\\", "\\\\") : src;
              const result = await execAsync(
                `go build -ldflags "-s -w" -o "${target}" ./${srcPath}`,
                {
                  cwd: project,
                  env: {
                    ...process.env
                  }
                }
              );
            } catch (ex) {
              return {
                type: "error",
                errors: [String(ex)]
              };
            }
          }
          if (input.mode === "deploy") {
            try {
              const target = path9.join(input.out, "bootstrap");
              const srcPath = os3.platform() === "win32" ? src.replaceAll("\\", "\\\\") : src;
              await execAsync(
                `go build -ldflags "-s -w" -o "${target}" ./${srcPath}`,
                {
                  cwd: project,
                  env: {
                    ...process.env,
                    CGO_ENABLED: "0",
                    GOARCH: input.props.architecture === "arm_64" ? "arm64" : "amd64",
                    GOOS: "linux"
                  }
                }
              );
            } catch (ex) {
              return {
                type: "error",
                errors: [String(ex)]
              };
            }
          }
          return {
            type: "success",
            handler: "bootstrap"
          };
        }
      });
    });
  }
});

// src/runtime/handlers/rust.ts
var rust_exports = {};
__export(rust_exports, {
  useRustHandler: () => useRustHandler
});
import path10 from "path";
import fs10 from "fs/promises";
import { exec as exec4, spawn as spawn3 } from "child_process";
import { promisify as promisify2 } from "util";
var execAsync2, useRustHandler;
var init_rust = __esm({
  "src/runtime/handlers/rust.ts"() {
    "use strict";
    init_handlers();
    init_workers();
    init_context();
    init_error();
    init_server();
    init_fs();
    execAsync2 = promisify2(exec4);
    useRustHandler = Context.memo(async () => {
      const workers = await useRuntimeWorkers();
      const server = await useRuntimeServerConfig();
      const handlers = useRuntimeHandlers();
      const processes = /* @__PURE__ */ new Map();
      const sources = /* @__PURE__ */ new Map();
      const handlerName = process.platform === "win32" ? `handler.exe` : `handler`;
      handlers.register({
        shouldBuild: (input) => {
          if (!input.file.endsWith(".rs"))
            return false;
          const parent = sources.get(input.functionID);
          if (!parent)
            return false;
          const result = isChild(parent, input.file);
          return result;
        },
        canHandle: (input) => input.startsWith("rust"),
        startWorker: async (input) => {
          const proc = spawn3(path10.join(input.out, handlerName), {
            env: {
              ...process.env,
              ...input.environment,
              IS_LOCAL: "true",
              RUST_BACKTRACE: "1",
              AWS_LAMBDA_RUNTIME_API: `http://localhost:${server.port}/${input.workerID}`,
              AWS_LAMBDA_FUNCTION_MEMORY_SIZE: "1024"
            },
            cwd: input.out
          });
          proc.on("exit", () => workers.exited(input.workerID));
          proc.stdout.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          proc.stderr.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          processes.set(input.workerID, proc);
        },
        stopWorker: async (workerID) => {
          const proc = processes.get(workerID);
          if (proc) {
            proc.kill();
            processes.delete(workerID);
          }
        },
        build: async (input) => {
          const parsed = path10.parse(input.props.handler);
          const project = await findAbove(parsed.dir, "Cargo.toml");
          if (!project)
            return {
              type: "error",
              errors: ["Could not find a Cargo.toml file"]
            };
          sources.set(input.functionID, project);
          if (input.mode === "start") {
            try {
              await execAsync2(`cargo build --bin ${parsed.name}`, {
                cwd: project,
                env: {
                  ...process.env
                }
              });
              await fs10.cp(
                path10.join(project, `target/debug`, parsed.name),
                path10.join(input.out, "handler")
              );
            } catch (ex) {
              throw new VisibleError("Failed to build");
            }
          }
          if (input.mode === "deploy") {
            try {
              await execAsync2(`cargo lambda build --release --bin ${parsed.name}`, {
                cwd: project,
                env: {
                  ...process.env
                }
              });
              await fs10.cp(
                path10.join(project, `target/lambda/`, parsed.name, "bootstrap"),
                path10.join(input.out, "bootstrap")
              );
            } catch (ex) {
              throw new VisibleError("Failed to build");
            }
          }
          return {
            type: "success",
            handler: "handler"
          };
        }
      });
    });
  }
});

// src/runtime/handlers/pythonBundling.ts
import fs11 from "fs";
import url5 from "url";
import path11 from "path";
import {
  DockerImage,
  FileSystem
} from "aws-cdk-lib";
function bundle(options) {
  const { entry, runtime, outputPathSuffix, installCommands } = options;
  const stagedir = FileSystem.mkdtemp("python-bundling-");
  const hasDeps = stageDependencies(entry, stagedir);
  const hasInstallCommands = stageInstallCommands(
    installCommands || [],
    stagedir
  );
  const dockerfile = hasInstallCommands ? "Dockerfile.custom" : hasDeps ? "Dockerfile.dependencies" : "Dockerfile";
  fs11.copyFileSync(
    path11.join(__dirname, "../../support/python-runtime", dockerfile),
    path11.join(stagedir, dockerfile)
  );
  const image = DockerImage.fromBuild(stagedir, {
    buildArgs: {
      IMAGE: runtime.bundlingImage.image
    },
    file: dockerfile
  });
  const outputPath = path11.join(options.out, outputPathSuffix);
  if (hasDeps || hasInstallCommands) {
    image.cp(`${BUNDLER_DEPENDENCIES_CACHE}/.`, outputPath);
  }
  fs11.cpSync(entry, outputPath, {
    recursive: true
  });
}
function stageDependencies(entry, stagedir) {
  const prefixes = ["Pipfile", "pyproject", "poetry", "requirements.txt"];
  let found = false;
  for (const file of fs11.readdirSync(entry)) {
    for (const prefix of prefixes) {
      if (file.startsWith(prefix)) {
        fs11.copyFileSync(path11.join(entry, file), path11.join(stagedir, file));
        found = true;
      }
    }
  }
  return found;
}
function stageInstallCommands(installCommands, stagedir) {
  let found = false;
  if (installCommands.length > 0) {
    const filePath = path11.join(stagedir, "sst-deps-install-command.sh");
    fs11.writeFileSync(filePath, installCommands.join(" && "));
    fs11.chmodSync(filePath, "755");
    found = true;
  }
  return found;
}
var __dirname, BUNDLER_DEPENDENCIES_CACHE;
var init_pythonBundling = __esm({
  "src/runtime/handlers/pythonBundling.ts"() {
    "use strict";
    __dirname = path11.dirname(url5.fileURLToPath(import.meta.url));
    BUNDLER_DEPENDENCIES_CACHE = "/var/dependencies";
  }
});

// src/runtime/handlers/python.ts
var python_exports = {};
__export(python_exports, {
  usePythonHandler: () => usePythonHandler
});
import path12 from "path";
import { exec as exec5, spawn as spawn4 } from "child_process";
import { promisify as promisify3 } from "util";
import { Runtime } from "aws-cdk-lib/aws-lambda";
import os4 from "os";
import url6 from "url";
var execAsync3, RUNTIME_MAP, usePythonHandler;
var init_python = __esm({
  "src/runtime/handlers/python.ts"() {
    "use strict";
    init_handlers();
    init_workers();
    init_context();
    init_server();
    init_fs();
    init_pythonBundling();
    execAsync3 = promisify3(exec5);
    RUNTIME_MAP = {
      "python2.7": Runtime.PYTHON_2_7,
      "python3.6": Runtime.PYTHON_3_6,
      "python3.7": Runtime.PYTHON_3_7,
      "python3.8": Runtime.PYTHON_3_8,
      "python3.9": Runtime.PYTHON_3_9
    };
    usePythonHandler = Context.memo(async () => {
      const workers = await useRuntimeWorkers();
      const server = await useRuntimeServerConfig();
      const handlers = useRuntimeHandlers();
      const processes = /* @__PURE__ */ new Map();
      const sources = /* @__PURE__ */ new Map();
      async function findSrc(input) {
        const hints = ["requirements.txt", "Pipfile", "poetry.lock"];
        for (const hint of hints) {
          const result = await findAbove(input, hint);
          if (result)
            return result;
        }
      }
      handlers.register({
        shouldBuild: (input) => {
          const parent = sources.get(input.functionID);
          if (!parent)
            return false;
          return isChild(parent, input.file);
        },
        canHandle: (input) => input.startsWith("python"),
        startWorker: async (input) => {
          const src = await findSrc(input.handler);
          if (!src)
            throw new Error(`Could not find src for ${input.handler}`);
          const parsed = path12.parse(path12.relative(src, input.handler));
          const target = [...parsed.dir.split(path12.sep), parsed.name].join(".");
          const proc = spawn4(
            os4.platform() === "win32" ? "python.exe" : "python3",
            [
              "-u",
              url6.fileURLToPath(
                new URL("../../support/python-runtime/runtime.py", import.meta.url)
              ),
              target,
              src,
              parsed.ext.substring(1)
            ],
            {
              env: {
                ...process.env,
                ...input.environment,
                IS_LOCAL: "true",
                AWS_LAMBDA_FUNCTION_MEMORY_SIZE: "1024",
                AWS_LAMBDA_RUNTIME_API: `localhost:${server.port}/${input.workerID}`
              },
              shell: true,
              cwd: src
            }
          );
          proc.on("exit", () => workers.exited(input.workerID));
          proc.stdout.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          proc.stderr.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          processes.set(input.workerID, proc);
        },
        stopWorker: async (workerID) => {
          const proc = processes.get(workerID);
          if (proc) {
            proc.kill();
            processes.delete(workerID);
          }
        },
        build: async (input) => {
          if (input.mode === "start")
            return {
              type: "success",
              handler: input.props.handler
            };
          const src = await findSrc(input.props.handler);
          if (!src)
            return {
              type: "error",
              errors: [`Could not find src for ${input.props.handler}`]
            };
          bundle({
            installCommands: input.props.python?.installCommands,
            entry: src,
            runtime: RUNTIME_MAP[input.props.runtime],
            outputPathSuffix: ".",
            out: input.out
          });
          return {
            type: "success",
            handler: path12.relative(src, path12.resolve(input.props.handler)).split(path12.sep).join(path12.posix.sep)
          };
        }
      });
    });
  }
});

// src/runtime/handlers/java.ts
var java_exports = {};
__export(java_exports, {
  useJavaHandler: () => useJavaHandler
});
import path13 from "path";
import fs12 from "fs/promises";
import os5 from "os";
import zipLocal from "zip-local";
import { spawn as spawn5 } from "child_process";
import url7 from "url";
async function getGradleBinary(srcPath) {
  const gradleWrapperPath = path13.resolve(path13.join(srcPath, "gradlew"));
  return await existsAsync(gradleWrapperPath) ? gradleWrapperPath : "gradle";
}
var useJavaHandler;
var init_java = __esm({
  "src/runtime/handlers/java.ts"() {
    "use strict";
    init_handlers();
    init_workers();
    init_context();
    init_server();
    init_fs();
    init_project();
    init_process();
    useJavaHandler = Context.memo(async () => {
      const workers = await useRuntimeWorkers();
      const server = await useRuntimeServerConfig();
      const handlers = useRuntimeHandlers();
      const processes = /* @__PURE__ */ new Map();
      const sources = /* @__PURE__ */ new Map();
      const handlerName = process.platform === "win32" ? `handler.exe` : `handler`;
      handlers.register({
        shouldBuild: (input) => {
          if (!input.file.endsWith(".java"))
            return false;
          const parent = sources.get(input.functionID);
          if (!parent)
            return false;
          return isChild(parent, input.file);
        },
        canHandle: (input) => input.startsWith("java"),
        startWorker: async (input) => {
          const proc = spawn5(
            `java`,
            [
              `-cp`,
              [
                url7.fileURLToPath(
                  new URL("../../support/java-runtime/release/*", import.meta.url)
                )
              ].join(os5.platform() === "win32" ? ";" : ":"),
              "com.amazonaws.services.lambda.runtime.api.client.AWSLambda",
              input.handler
            ],
            {
              env: {
                ...process.env,
                ...input.environment,
                IS_LOCAL: "true",
                AWS_LAMBDA_RUNTIME_API: `localhost:${server.port}/${input.workerID}`
              },
              cwd: input.out
            }
          );
          proc.on("exit", () => workers.exited(input.workerID));
          proc.stdout.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          proc.stderr.on("data", (data2) => {
            workers.stdout(input.workerID, data2.toString());
          });
          processes.set(input.workerID, proc);
        },
        stopWorker: async (workerID) => {
          const proc = processes.get(workerID);
          if (proc) {
            proc.kill();
            processes.delete(workerID);
          }
        },
        build: async (input) => {
          const project = useProject();
          const srcPath = await findBelow(project.paths.root, "build.gradle");
          const buildBinary = await getGradleBinary(srcPath);
          const buildTask = input.props.java?.buildTask || "build";
          const outputDir = input.props.java?.buildOutputDir || "distributions";
          sources.set(input.functionID, srcPath);
          try {
            await execAsync(
              `${buildBinary} ${buildTask} -Dorg.gradle.logging.level=${process.env.DEBUG ? "debug" : "lifecycle"}`,
              {
                cwd: srcPath
              }
            );
            const buildOutput = path13.join(srcPath, "build", outputDir);
            const zip = (await fs12.readdir(buildOutput)).find(
              (f) => f.endsWith(".zip")
            );
            zipLocal.sync.unzip(path13.join(buildOutput, zip)).save(input.out);
            return {
              type: "success",
              handler: input.props.handler
            };
          } catch (ex) {
            return {
              type: "error",
              errors: [ex.stderr]
            };
          }
        }
      });
    });
  }
});

// src/stacks/synth.ts
import * as contextproviders from "sst-aws-cdk/lib/context-providers/index.js";
import path14 from "path";
async function synth(opts) {
  Logger.debug("Synthesizing stacks...");
  const { App: App2 } = await import("../src/constructs/App.js");
  const { useNodeHandler: useNodeHandler2 } = await Promise.resolve().then(() => (init_node(), node_exports));
  const { useGoHandler: useGoHandler2 } = await Promise.resolve().then(() => (init_go(), go_exports));
  const { useRustHandler: useRustHandler2 } = await Promise.resolve().then(() => (init_rust(), rust_exports));
  const { usePythonHandler: usePythonHandler2 } = await Promise.resolve().then(() => (init_python(), python_exports));
  const { useJavaHandler: useJavaHandler2 } = await Promise.resolve().then(() => (init_java(), java_exports));
  useNodeHandler2();
  useGoHandler2();
  usePythonHandler2();
  useJavaHandler2();
  useDotnetHandler();
  useRustHandler2();
  const { Configuration } = await import("sst-aws-cdk/lib/settings.js");
  const project = useProject();
  const identity = await useSTSIdentity();
  opts = {
    ...opts,
    buildDir: opts.buildDir || path14.join(project.paths.out, "dist")
  };
  const cfg = new Configuration();
  await cfg.load();
  let previous2 = /* @__PURE__ */ new Set();
  while (true) {
    const app = new App2(
      {
        account: identity.Account,
        stage: project.config.stage,
        name: project.config.name,
        region: project.config.region,
        mode: opts.mode,
        debugIncreaseTimeout: opts.increaseTimeout,
        isActiveStack: opts.isActiveStack
      },
      {
        outdir: opts.buildDir,
        context: cfg.context.all
      }
    );
    await opts.fn(app);
    await app.finish();
    const assembly = app.synth();
    Logger.debug(assembly.manifest.missing);
    const { missing } = assembly.manifest;
    const provider = await useAWSProvider();
    if (missing && missing.length) {
      const next = missing.map((x) => x.key);
      if (next.length === previous2.size && next.every((x) => previous2.has(x)))
        throw new VisibleError(formatErrorMessage(next.join("")));
      Logger.debug("Looking up context for:", next, "Previous:", previous2);
      previous2 = new Set(next);
      await contextproviders.provideContextValues(
        missing,
        cfg.context,
        provider
      );
      if (cfg.context.keys.length) {
        await cfg.saveContext();
      }
      continue;
    }
    Logger.debug("Finished synthesizing");
    return assembly;
  }
}
function formatErrorMessage(message) {
  return formatCustomDomainError(message) || `Could not resolve context values for ${message}`;
}
function formatCustomDomainError(message) {
  const ret = message.match(/hosted-zone:account=\d+:domainName=(\S+):/);
  if (!ret) {
    return;
  }
  const hostedZone = ret && ret[1];
  return [
    `It seems you are configuring custom domains for you URL.`,
    hostedZone ? `And SST is not able to find the hosted zone "${hostedZone}" in your AWS Route 53 account.` : `And SST is not able to find the hosted zone in your AWS Route 53 account.`,
    `Please double check and make sure the zone exists, or pass in a different zone.`
  ].join(" ");
}
var init_synth = __esm({
  "src/stacks/synth.ts"() {
    "use strict";
    init_logger();
    init_project();
    init_credentials();
    init_error();
    init_dotnet();
  }
});

// src/stacks/remove.ts
import {
  CloudFormationClient as CloudFormationClient2,
  DeleteStackCommand
} from "@aws-sdk/client-cloudformation";
async function removeMany(stacks) {
  await useAWSProvider();
  const bus = useBus();
  const complete = /* @__PURE__ */ new Set();
  const todo = new Set(stacks.map((s) => s.id));
  const results = {};
  return new Promise((resolve) => {
    async function trigger() {
      for (const stack of stacks) {
        if (!todo.has(stack.id))
          continue;
        Logger.debug("Checking if", stack.id, "can be removed");
        const waiting = stacks.filter((dependant) => {
          if (dependant.id === stack.id)
            return false;
          if (complete.has(dependant.id))
            return false;
          return dependant.dependencies?.some((d) => d.id === stack.id);
        });
        if (waiting.length) {
          Logger.debug(
            "Waiting on",
            waiting.map((s) => s.id)
          );
          continue;
        }
        remove(stack).then((result) => {
          results[stack.id] = result;
          complete.add(stack.id);
          if (isFailed(result.status))
            stacks.forEach((s) => {
              if (todo.delete(s.stackName)) {
                complete.add(s.stackName);
                results[s.id] = {
                  status: "DEPENDENCY_FAILED",
                  outputs: {},
                  errors: {}
                };
                bus.publish("stack.status", {
                  stackID: s.id,
                  status: "DEPENDENCY_FAILED"
                });
              }
            });
          if (complete.size === stacks.length) {
            resolve(results);
          }
          trigger();
        });
        todo.delete(stack.id);
      }
    }
    trigger();
  });
}
async function remove(stack) {
  Logger.debug("Removing stack", stack.id);
  const cfn = useAWSClient(CloudFormationClient2);
  try {
    await cfn.send(
      new DeleteStackCommand({
        StackName: stack.stackName
      })
    );
    return monitor(stack.stackName);
  } catch (ex) {
    return {
      errors: {
        stack: ex.message
      },
      outputs: {},
      status: "UPDATE_FAILED"
    };
  }
}
var init_remove = __esm({
  "src/stacks/remove.ts"() {
    "use strict";
    init_bus();
    init_credentials();
    init_logger();
    init_monitor();
  }
});

// src/stacks/index.ts
var stacks_exports = {};
__export(stacks_exports, {
  STATUSES: () => STATUSES,
  Stacks: () => stacks_exports,
  clearAppMetadata: () => clearAppMetadata,
  deploy: () => deploy,
  deployMany: () => deployMany,
  diff: () => diff,
  filterOutputs: () => filterOutputs,
  isFailed: () => isFailed,
  isFinal: () => isFinal,
  isPending: () => isPending,
  isSuccess: () => isSuccess,
  load: () => load,
  loadAssembly: () => loadAssembly,
  metadata: () => metadata2,
  monitor: () => monitor,
  publishAssets: () => publishAssets4,
  remove: () => remove,
  removeMany: () => removeMany,
  saveAppMetadata: () => saveAppMetadata,
  synth: () => synth,
  useAppMetadata: () => useAppMetadata,
  useMetadata: () => useMetadata
});
var init_stacks = __esm({
  "src/stacks/index.ts"() {
    "use strict";
    init_app_metadata();
    init_assembly();
    init_build();
    init_deploy();
    init_diff();
    init_metadata();
    init_synth();
    init_monitor();
    init_remove();
    init_stacks();
  }
});

// src/bootstrap.ts
var bootstrap_exports = {};
__export(bootstrap_exports, {
  bootstrapSST: () => bootstrapSST,
  useBootstrap: () => useBootstrap
});
import url8 from "url";
import path15 from "path";
import { bold, dim } from "colorette";
import { spawn as spawn6 } from "child_process";
import {
  DescribeStacksCommand as DescribeStacksCommand2,
  CloudFormationClient as CloudFormationClient3
} from "@aws-sdk/client-cloudformation";
import {
  App,
  DefaultStackSynthesizer,
  CfnOutput,
  Duration,
  Tags,
  Stack,
  RemovalPolicy
} from "aws-cdk-lib";
import { Function, Runtime as Runtime2, Code } from "aws-cdk-lib/aws-lambda";
import { SqsEventSource } from "aws-cdk-lib/aws-lambda-event-sources";
import { PolicyStatement } from "aws-cdk-lib/aws-iam";
import { Queue } from "aws-cdk-lib/aws-sqs";
import { Rule } from "aws-cdk-lib/aws-events";
import { SqsQueue } from "aws-cdk-lib/aws-events-targets";
import {
  BlockPublicAccess,
  Bucket,
  BucketEncryption
} from "aws-cdk-lib/aws-s3";
async function loadCDKStatus() {
  const { cdk } = useProject().config;
  const client = useAWSClient(CloudFormationClient3);
  const stackName = cdk?.toolkitStackName || CDK_STACK_NAME;
  try {
    const { Stacks: stacks } = await client.send(
      new DescribeStacksCommand2({ StackName: stackName })
    );
    if (!stacks || stacks.length === 0)
      return false;
    if (!["CREATE_COMPLETE", "UPDATE_COMPLETE"].includes(stacks[0].StackStatus)) {
      return false;
    }
    const output = stacks[0].Outputs?.find(
      (o) => o.OutputKey === "BootstrapVersion"
    );
    if (!output || parseInt(output.OutputValue) < 14)
      return false;
    return true;
  } catch (e) {
    if (e.name === "ValidationError" && e.message === `Stack with id ${stackName} does not exist`) {
      return false;
    } else {
      throw e;
    }
  }
}
async function loadSSTStatus() {
  const { bootstrap: bootstrap2 } = useProject().config;
  const cf = useAWSClient(CloudFormationClient3);
  const stackName = bootstrap2?.stackName || SST_STACK_NAME;
  let result;
  try {
    result = await cf.send(
      new DescribeStacksCommand2({
        StackName: stackName
      })
    );
  } catch (e) {
    if (e.Code === "ValidationError" && e.message === `Stack with id ${stackName} does not exist`) {
      return null;
    }
    throw e;
  }
  let version2, bucket;
  (result.Stacks[0].Outputs || []).forEach((o) => {
    if (o.OutputKey === OUTPUT_VERSION) {
      version2 = o.OutputValue;
    } else if (o.OutputKey === OUTPUT_BUCKET) {
      bucket = o.OutputValue;
    }
  });
  if (!version2 || !bucket) {
    return null;
  }
  return { version: version2, bucket };
}
async function bootstrapSST() {
  const { region, bootstrap: bootstrap2, cdk } = useProject().config;
  const app = new App();
  const stackName = bootstrap2?.stackName || SST_STACK_NAME;
  const stack = new Stack(app, stackName, {
    env: {
      region
    },
    synthesizer: new DefaultStackSynthesizer({
      qualifier: cdk?.qualifier,
      fileAssetsBucketName: cdk?.fileAssetsBucketName
    })
  });
  for (const [key, value] of Object.entries(bootstrap2?.tags || {})) {
    Tags.of(app).add(key, value);
  }
  const bucket = new Bucket(stack, region, {
    encryption: BucketEncryption.S3_MANAGED,
    removalPolicy: RemovalPolicy.DESTROY,
    autoDeleteObjects: true,
    blockPublicAccess: cdk?.publicAccessBlockConfiguration !== false ? BlockPublicAccess.BLOCK_ALL : void 0
  });
  const fn = new Function(stack, "MetadataHandler", {
    code: Code.fromAsset(
      path15.resolve(__dirname2, "support/bootstrap-metadata-function")
    ),
    handler: "index.handler",
    runtime: region?.startsWith("us-gov-") ? Runtime2.NODEJS_16_X : Runtime2.NODEJS_18_X,
    environment: {
      BUCKET_NAME: bucket.bucketName
    },
    initialPolicy: [
      new PolicyStatement({
        actions: ["cloudformation:DescribeStacks"],
        resources: ["*"]
      }),
      new PolicyStatement({
        actions: ["s3:PutObject", "s3:DeleteObject"],
        resources: [bucket.bucketArn + "/*"]
      }),
      new PolicyStatement({
        actions: ["iot:Publish"],
        resources: [
          `arn:${stack.partition}:iot:${stack.region}:${stack.account}:topic//sst/*`
        ]
      })
    ]
  });
  const queue = new Queue(stack, "MetadataQueue", {
    visibilityTimeout: Duration.seconds(30),
    retentionPeriod: Duration.minutes(2)
  });
  fn.addEventSource(new SqsEventSource(queue));
  const rule = new Rule(stack, "MetadataRule", {
    eventPattern: {
      source: ["aws.cloudformation"],
      detailType: ["CloudFormation Stack Status Change"],
      detail: {
        "status-details": {
          status: [
            "CREATE_COMPLETE",
            "UPDATE_COMPLETE",
            "UPDATE_ROLLBACK_COMPLETE",
            "ROLLBACK_COMPLETE",
            "DELETE_COMPLETE"
          ]
        }
      }
    }
  });
  rule.addTarget(
    new SqsQueue(queue, {
      retryAttempts: 10
    })
  );
  new CfnOutput(stack, OUTPUT_VERSION, { value: LATEST_VERSION });
  new CfnOutput(stack, OUTPUT_BUCKET, { value: bucket.bucketName });
  const asm = app.synth();
  const result = await stacks_exports.deploy(asm.stacks[0]);
  if (stacks_exports.isFailed(result.status)) {
    throw new VisibleError(
      `Failed to deploy bootstrap stack:
${JSON.stringify(
        result.errors,
        null,
        4
      )}`
    );
  }
}
async function bootstrapCDK() {
  const identity = await useSTSIdentity();
  const credentials = await useAWSCredentials();
  const { region, profile, cdk } = useProject().config;
  await new Promise((resolve, reject) => {
    const proc = spawn6(
      [
        "npx",
        "cdk",
        "bootstrap",
        `aws://${identity.Account}/${region}`,
        "--no-version-reporting",
        ...cdk?.publicAccessBlockConfiguration === false ? ["--public-access-block-configuration", "false"] : cdk?.publicAccessBlockConfiguration === true ? ["--public-access-block-configuration", "false"] : [],
        ...cdk?.toolkitStackName ? ["--toolkit-stack-name", cdk.toolkitStackName] : [],
        ...cdk?.qualifier ? ["--qualifier", cdk.qualifier] : [],
        ...cdk?.fileAssetsBucketName ? ["--toolkit-bucket-name", cdk.fileAssetsBucketName] : [],
        ...cdk?.customPermissionsBoundary ? ["--custom-permissions-boundary", cdk.customPermissionsBoundary] : []
      ].join(" "),
      {
        env: {
          ...process.env,
          AWS_ACCESS_KEY_ID: credentials.accessKeyId,
          AWS_SECRET_ACCESS_KEY: credentials.secretAccessKey,
          AWS_SESSION_TOKEN: credentials.sessionToken,
          AWS_REGION: region,
          AWS_PROFILE: profile
        },
        stdio: "pipe",
        shell: true
      }
    );
    let stderr = "";
    proc.stdout.on("data", (data2) => {
      Logger.debug(data2.toString());
    });
    proc.stderr.on("data", (data2) => {
      Logger.debug(data2.toString());
      stderr += data2;
    });
    proc.on("exit", (code) => {
      Logger.debug("CDK bootstrap exited with code " + code);
      if (code === 0) {
        resolve();
      } else {
        console.log(bold(dim(stderr)));
        reject(new VisibleError(`Failed to bootstrap`));
      }
    });
  });
}
var CDK_STACK_NAME, SST_STACK_NAME, OUTPUT_VERSION, OUTPUT_BUCKET, LATEST_VERSION, __dirname2, useBootstrap;
var init_bootstrap = __esm({
  "src/bootstrap.ts"() {
    "use strict";
    init_project();
    init_spinner();
    init_context();
    init_credentials();
    init_error();
    init_logger();
    init_stacks();
    CDK_STACK_NAME = "CDKToolkit";
    SST_STACK_NAME = "SSTBootstrap";
    OUTPUT_VERSION = "Version";
    OUTPUT_BUCKET = "BucketName";
    LATEST_VERSION = "7";
    __dirname2 = url8.fileURLToPath(new URL(".", import.meta.url));
    useBootstrap = Context.memo(async () => {
      Logger.debug("Initializing bootstrap context");
      let [cdkStatus, sstStatus] = await Promise.all([
        loadCDKStatus(),
        loadSSTStatus()
      ]);
      Logger.debug("Loaded bootstrap status");
      const needToBootstrapCDK = !cdkStatus;
      const needToBootstrapSST = !sstStatus || sstStatus.version !== LATEST_VERSION;
      if (needToBootstrapCDK || needToBootstrapSST) {
        const spinner = createSpinner(
          "Deploying bootstrap stack, this only needs to happen once"
        ).start();
        if (needToBootstrapCDK) {
          await bootstrapCDK();
        }
        if (needToBootstrapSST) {
          await bootstrapSST();
          sstStatus = await loadSSTStatus();
          if (!sstStatus)
            throw new VisibleError("Failed to load bootstrap stack status");
        }
        spinner.succeed();
      }
      Logger.debug("Bootstrap context initialized", sstStatus);
      return sstStatus;
    }, "Bootstrap");
  }
});

// src/cli/local/router.ts
import * as trpc from "@trpc/server";
var router2;
var init_router = __esm({
  "src/cli/local/router.ts"() {
    "use strict";
    init_project();
    init_bus();
    init_credentials();
    router2 = trpc.router().query("getCredentials", {
      async resolve({ ctx }) {
        const project = useProject();
        const credentials = await useAWSCredentials();
        return {
          region: project.config.region,
          credentials: {
            accessKeyId: credentials.accessKeyId,
            secretAccessKey: credentials.secretAccessKey,
            sessionToken: credentials.sessionToken
          }
        };
      }
    }).query("getState", {
      async resolve({ ctx }) {
        return ctx.state;
      }
    }).mutation("deploy", {
      async resolve() {
        return;
      }
    }).subscription("onStateChange", {
      async resolve({ ctx }) {
        const bus = useBus();
        return new trpc.Subscription((emit) => {
          const sub = bus.subscribe("local.patches", (evt) => {
            emit.data(evt.properties);
          });
          return () => {
            bus.unsubscribe(sub);
          };
        });
      }
    });
  }
});

// src/cli/local/server.ts
var server_exports2 = {};
__export(server_exports2, {
  useLocalServer: () => useLocalServer,
  useLocalServerConfig: () => useLocalServerConfig
});
import { produceWithPatches, enablePatches } from "immer";
import express2 from "express";
import fs13 from "fs/promises";
import { WebSocketServer } from "ws";
import https3 from "https";
import http from "http";
import { applyWSSHandler } from "@trpc/server/adapters/ws/dist/trpc-server-adapters-ws.cjs.js";
import { optimise } from "dendriform-immer-patch-optimiser";
import { sync } from "cross-spawn";
import getPort2 from "get-port";
async function useLocalServer(opts) {
  const cfg = await useLocalServerConfig();
  const project = useProject();
  let state2 = {
    app: project.config.name,
    stage: project.config.stage,
    bootstrap: project.config.bootstrap,
    live: opts.live,
    stacks: {
      status: "idle"
    },
    functions: {}
  };
  const rest = express2();
  rest.all(`/ping`, (req, res) => {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Methods", "GET, PUT, PATCH, POST, DELETE");
    res.header(
      "Access-Control-Allow-Headers",
      req.header("access-control-request-headers")
    );
    res.sendStatus(200);
  });
  rest.all(
    `/proxy*`,
    express2.raw({
      type: "*/*",
      limit: "1024mb"
    }),
    (req, res) => {
      res.header("Access-Control-Allow-Origin", "*");
      res.header(
        "Access-Control-Allow-Methods",
        "GET, PUT, PATCH, POST, DELETE"
      );
      res.header(
        "Access-Control-Allow-Headers",
        req.header("access-control-request-headers")
      );
      if (req.method === "OPTIONS")
        return res.send();
      const u = new URL(req.url.substring(7));
      const forward = https3.request(
        u,
        {
          headers: {
            ...req.headers,
            host: u.hostname
          },
          method: req.method
        },
        (proxied) => {
          res.status(proxied.statusCode);
          for (const [key, value] of Object.entries(proxied.headers)) {
            res.header(key, value);
          }
          proxied.pipe(res);
        }
      );
      if (req.method !== "GET" && req.method !== "DELETE" && req.method !== "HEAD" && req.body)
        forward.write(req.body);
      forward.end();
      forward.on("error", (e) => {
        console.log(e.message);
      });
    }
  );
  const server = await (async () => {
    const result2 = sync("mkcert", ["--help"]);
    const KEY_PATH = ".sst/localhost-key.pem";
    const CERT_PATH = ".sst/localhost.pem";
    if (result2.status === 0) {
      try {
        await Promise.all([fs13.access(KEY_PATH), fs13.access(CERT_PATH)]);
      } catch (e) {
        sync("mkcert", ["localhost"], {
          cwd: ".sst"
        });
      }
      const [key, cert] = await Promise.all([
        fs13.readFile(KEY_PATH),
        fs13.readFile(CERT_PATH)
      ]);
      return https3.createServer(
        {
          key,
          cert
        },
        rest
      );
    }
    return http.createServer({}, rest);
  })();
  const wss = new WebSocketServer({ server });
  wss.on("connection", (socket, req) => {
    if (req.headers.origin?.endsWith("localhost:3000"))
      return;
    if (req.headers.origin?.endsWith("localhost:3001"))
      return;
    if (req.headers.origin?.endsWith("console.serverless-stack.com"))
      return;
    if (req.headers.origin?.endsWith("console.sst.dev"))
      return;
    if (req.headers.origin?.endsWith("--sst-console.netlify.app"))
      return;
    console.log("Rejecting unauthorized connection from " + req.headers.origin);
    socket.terminate();
  });
  server.listen(cfg.port);
  const handler = applyWSSHandler({
    wss,
    router: router2,
    createContext() {
      return {
        state: state2
      };
    }
  });
  process.on("SIGTERM", () => {
    handler.broadcastReconnectNotification();
    wss.close();
  });
  const bus = useBus();
  const pending = [];
  function updateState(cb) {
    const [next, patches] = produceWithPatches(state2, cb);
    if (!patches.length)
      return;
    const scheduled = pending.length;
    pending.push(...optimise(state2, patches));
    if (!scheduled)
      setTimeout(() => {
        bus.publish("local.patches", pending);
        pending.splice(0, pending.length);
      }, 0);
    state2 = next;
  }
  function updateFunction(id, cb) {
    return updateState((draft) => {
      let func = draft.functions[id];
      if (!func) {
        func = {
          warm: true,
          state: "idle",
          issues: {},
          invocations: []
        };
        draft.functions[id] = func;
      }
      cb(func);
    });
  }
  bus.subscribe("function.invoked", (evt) => {
    updateFunction(evt.properties.functionID, (draft) => {
      if (draft.invocations.length >= 25)
        draft.invocations.pop();
      draft.invocations.unshift({
        id: evt.properties.context.awsRequestId,
        request: evt.properties.event,
        times: {
          start: Date.now()
        },
        logs: []
      });
    });
  });
  bus.subscribe("worker.stdout", (evt) => {
    updateFunction(evt.properties.functionID, (draft) => {
      const entry = draft.invocations.find(
        (i) => i.id === evt.properties.requestID
      );
      if (!entry)
        return;
      entry.logs.push({
        timestamp: Date.now(),
        message: evt.properties.message
      });
    });
  });
  bus.subscribe("function.success", (evt) => {
    updateFunction(evt.properties.functionID, (draft) => {
      const invocation = draft.invocations.find(
        (x) => x.id === evt.properties.requestID
      );
      if (!invocation)
        return;
      invocation.response = {
        type: "success",
        data: evt.properties.body
      };
      invocation.times.end = Date.now();
    });
  });
  bus.subscribe("function.error", (evt) => {
    updateFunction(evt.properties.functionID, (draft) => {
      const invocation = draft.invocations.find(
        (x) => x.id === evt.properties.requestID
      );
      if (!invocation)
        return;
      invocation.response = {
        type: "failure",
        error: {
          errorMessage: evt.properties.errorMessage,
          stackTrace: evt.properties.trace || []
        }
      };
      invocation.times.end = Date.now();
    });
  });
  const result = {
    updateState,
    updateFunction
  };
  return result;
}
var useLocalServerConfig;
var init_server2 = __esm({
  "src/cli/local/server.ts"() {
    "use strict";
    init_router();
    init_project();
    init_bus();
    init_context();
    enablePatches();
    useLocalServerConfig = Context.memo(async () => {
      const project = useProject();
      const port = await getPort2({
        port: 13557
      });
      return {
        port,
        url: `https://console.sst.dev/${project.config.name}/${project.config.stage}${port !== 13557 ? `?_port=${port}` : ""}`
      };
    });
  }
});

// src/cli/ui/header.ts
var header_exports = {};
__export(header_exports, {
  printConsole: () => printConsole,
  printHeader: () => printHeader
});
async function printHeader(input) {
  const project = useProject();
  Colors.line(
    `${Colors.primary.bold(`SST v${project.version}`)}  ${input.hint ? Colors.dim(`ready!`) : ""}`
  );
  Colors.gap();
  Colors.line(
    `${Colors.primary(`\u279C`)}  ${Colors.bold("App:")}     ${project.config.name}`
  );
  Colors.line(
    `${Colors.primary(` `)}  ${Colors.bold("Stage:")}   ${project.config.stage}`
  );
  if (input.console) {
    const local = await useLocalServerConfig();
    Colors.line(
      `${Colors.primary(` `)}  ${Colors.bold("Console:")} ${Colors.link(
        local.url
      )}`
    );
  }
  Colors.gap();
}
function printConsole() {
}
var init_header = __esm({
  "src/cli/ui/header.ts"() {
    "use strict";
    init_project();
    init_colors();
    init_server2();
  }
});

// src/iot.ts
var iot_exports = {};
__export(iot_exports, {
  useIOT: () => useIOT,
  useIOTEndpoint: () => useIOTEndpoint
});
import { IoTClient, DescribeEndpointCommand } from "@aws-sdk/client-iot";
import iot from "aws-iot-device-sdk";
import { PutObjectCommand as PutObjectCommand2, S3Client as S3Client3 } from "@aws-sdk/client-s3";
var useIOTEndpoint, useIOT;
var init_iot = __esm({
  "src/iot.ts"() {
    "use strict";
    init_context();
    init_credentials();
    init_error();
    init_bus();
    init_project();
    init_logger();
    init_bootstrap();
    useIOTEndpoint = Context.memo(async () => {
      const iot2 = useAWSClient(IoTClient);
      Logger.debug("Getting IoT endpoint");
      const response = await iot2.send(
        new DescribeEndpointCommand({
          endpointType: "iot:Data-ATS"
        })
      );
      Logger.debug("Using IoT endpoint:", response.endpointAddress);
      if (!response.endpointAddress)
        throw new VisibleError("IoT Endpoint address not found");
      return response.endpointAddress;
    });
    useIOT = Context.memo(async () => {
      const bus = useBus();
      const endpoint = await useIOTEndpoint();
      const creds = await useAWSCredentials();
      const project = useProject();
      const bootstrap2 = await useBootstrap();
      const s3 = useAWSClient(S3Client3);
      async function encode(input) {
        const id = Math.random().toString();
        const json = JSON.stringify(input);
        if (json.length > 1024 * 1024 * 3) {
          const key = `pointers/${id}`;
          await s3.send(
            new PutObjectCommand2({
              Bucket: bootstrap2.bucket,
              Key: key,
              Body: json
            })
          );
          return [
            {
              id,
              index: 0,
              count: 1,
              data: JSON.stringify({
                type: "pointer",
                properties: {
                  key,
                  bucket: bootstrap2.bucket
                }
              })
            }
          ];
        }
        const parts = json.match(/.{1,50000}/g);
        if (!parts)
          return [];
        Logger.debug("Encoded iot message into", parts?.length, "parts");
        return parts.map((part, index) => ({
          id,
          index,
          count: parts?.length,
          data: part
        }));
      }
      const device = new iot.device({
        protocol: "wss",
        host: endpoint,
        region: project.config.region,
        accessKeyId: creds.accessKeyId,
        secretKey: creds.secretAccessKey,
        sessionToken: creds.sessionToken,
        reconnectPeriod: 1
      });
      const PREFIX2 = `/sst/${project.config.name}/${project.config.stage}`;
      device.subscribe(`${PREFIX2}/events`, { qos: 1 });
      const fragments = /* @__PURE__ */ new Map();
      device.on("connect", () => {
        Logger.debug("IoT connected");
      });
      device.on("error", (err) => {
        Logger.debug("IoT error", err);
      });
      device.on("close", () => {
        Logger.debug("IoT closed");
      });
      device.on("reconnect", () => {
        Logger.debug("IoT reconnected");
      });
      device.on("message", (_topic, buffer) => {
        const fragment = JSON.parse(buffer.toString());
        if (!fragment.id) {
          bus.publish(fragment.type, fragment.properties);
          return;
        }
        let pending = fragments.get(fragment.id);
        if (!pending) {
          pending = /* @__PURE__ */ new Map();
          fragments.set(fragment.id, pending);
        }
        pending.set(fragment.index, fragment);
        if (pending.size === fragment.count) {
          const data2 = [...pending.values()].sort((a, b) => a.index - b.index).map((item) => item.data).join("");
          fragments.delete(fragment.id);
          const evt = JSON.parse(data2);
          if (evt.sourceID === bus.sourceID)
            return;
          bus.publish(evt.type, evt.properties);
        }
      });
      return {
        prefix: PREFIX2,
        async publish(topic, type, properties) {
          const payload = {
            type,
            properties,
            sourceID: bus.sourceID
          };
          for (const fragment of await encode(payload)) {
            await new Promise((r) => {
              device.publish(
                topic,
                JSON.stringify(fragment),
                {
                  qos: 1
                },
                () => {
                  r();
                }
              );
            });
          }
          Logger.debug("IOT Published", topic, type);
        }
      };
    });
  }
});

// src/runtime/iot.ts
var iot_exports2 = {};
__export(iot_exports2, {
  useIOTBridge: () => useIOTBridge
});
var useIOTBridge;
var init_iot2 = __esm({
  "src/runtime/iot.ts"() {
    "use strict";
    init_context();
    init_bus();
    init_iot();
    useIOTBridge = Context.memo(async () => {
      const bus = useBus();
      const iot2 = await useIOT();
      const topic = `${iot2.prefix}/events`;
      bus.subscribe("function.success", async (evt) => {
        iot2.publish(
          topic + "/" + evt.properties.workerID,
          "function.success",
          evt.properties
        );
      });
      bus.subscribe("function.error", async (evt) => {
        iot2.publish(
          topic + "/" + evt.properties.workerID,
          "function.error",
          evt.properties
        );
      });
      bus.subscribe("function.ack", async (evt) => {
        iot2.publish(
          topic + "/" + evt.properties.workerID,
          "function.ack",
          evt.properties
        );
      });
    });
  }
});

// src/cli/ui/deploy.tsx
var deploy_exports = {};
__export(deploy_exports, {
  DeploymentUI: () => DeploymentUI,
  printDeploymentResults: () => printDeploymentResults
});
import React, { useState, useEffect } from "react";
import { Box, Text } from "ink";
import Spinner from "ink-spinner";
function printDeploymentResults(assembly, results, remove4) {
  const success = Object.entries(results).filter(
    ([_stack, result]) => stacks_exports.isSuccess(result.status)
  );
  if (success.length) {
    Colors.gap();
    Colors.line(
      Colors.success(`\u2714`),
      Colors.bold(remove4 ? ` Removed:` : ` Deployed:`)
    );
    for (const [stack, result] of success) {
      Colors.line(`   ${Colors.dim(stackNameToId(stack))}`);
      for (const key of Object.keys(result.outputs).sort()) {
        const value = result.outputs[key];
        Colors.line(`   ${Colors.bold.dim(key + ":")} ${value}`);
      }
    }
    Colors.gap();
  }
  const failed = Object.entries(results).filter(
    ([_stack, result]) => stacks_exports.isFailed(result.status)
  );
  if (failed.length) {
    Colors.gap();
    Colors.line(`${Colors.danger(`\u2716`)}  ${Colors.bold.dim(`Errors`)}`);
    for (const [stack, result] of failed) {
      Colors.line(
        `   ${Colors.dim(stackNameToId(stack))} ${Colors.dim(result.status)}`
      );
      for (const [id, error2] of Object.entries(result.errors)) {
        const readable = logicalIdToCdkPath(assembly, stack, id) || id;
        Colors.line(`   ${Colors.danger.bold(readable + ":")} ${error2}`);
        const helper = getHelper(error2);
        if (helper) {
          Colors.line(`   ${Colors.warning.bold("\u2B91  Hint:")} ${helper}`);
        }
      }
    }
    Colors.gap();
  }
}
function stackNameToId(stack) {
  const project = useProject();
  const prefix = `${project.config.stage}-${project.config.name}-`;
  return stack.startsWith(prefix) ? stack.substring(prefix.length) : stack;
}
function logicalIdToCdkPath(assembly, stack, logicalId) {
  const found = Object.entries(
    assembly.manifest.artifacts?.[stack]?.metadata || {}
  ).find(
    ([_key, value]) => value[0]?.type === "aws:cdk:logicalId" && value[0]?.data === logicalId
  )?.[0];
  if (!found) {
    return;
  }
  return found.split("/").filter(Boolean).slice(1, -1).join("/");
}
function getHelper(error2) {
  return getApiAccessLogPermissionsHelper(error2) || getAppSyncMultiResolverHelper(error2) || getApiLogRoleHelper(error2);
}
function getApiAccessLogPermissionsHelper(error2) {
  if (error2.indexOf("Insufficient permissions to enable logging") > -1) {
    return `This is a common deploy error. Check out this GitHub issue for more details - https://github.com/serverless-stack/sst/issues/125`;
  }
}
function getAppSyncMultiResolverHelper(error2) {
  if (error2.indexOf(
    "Only one resolver is allowed per field. (Service: AWSAppSync"
  ) > -1) {
    return `This is a common error for deploying AppSync APIs. Check out this GitHub issue for more details - https://github.com/aws/aws-cdk/issues/13269`;
  }
}
function getApiLogRoleHelper(error2) {
  if (error2.indexOf(
    "CloudWatch Logs role ARN must be set in account settings to enable logging (Service: AmazonApiGatewayV2"
  ) > -1) {
    return `This is a common error when configuring Access Log for WebSocket APIs. The AWS API Gateway service in your AWS account does not have permissions to the CloudWatch logs service. Follow this article to create an IAM role for logging to CloudWatch - https://aws.amazon.com/premiumsupport/knowledge-center/api-gateway-cloudwatch-logs/`;
  }
}
var DeploymentUI;
var init_deploy2 = __esm({
  "src/cli/ui/deploy.tsx"() {
    "use strict";
    init_bus();
    init_stacks();
    init_colors();
    init_project();
    DeploymentUI = (props) => {
      const [resources, setResources] = useState({});
      useEffect(() => {
        Colors.gap();
        const bus = useBus();
        const event = bus.subscribe("stack.event", (payload) => {
          const { event: event2 } = payload.properties;
          setResources((previous2) => {
            if (stacks_exports.isFinal(event2.ResourceStatus)) {
              const readable = logicalIdToCdkPath(
                props.assembly,
                event2.StackName,
                event2.LogicalResourceId
              );
              Colors.line(
                Colors.warning(Colors.prefix),
                readable ? Colors.dim(
                  `${stackNameToId(event2.StackName)} ${readable} ${event2.ResourceType}`
                ) : Colors.dim(
                  `${stackNameToId(event2.StackName)} ${event2.ResourceType}`
                ),
                stacks_exports.isFailed(event2.ResourceStatus) ? Colors.danger(event2.ResourceStatus) : Colors.dim(event2.ResourceStatus),
                stacks_exports.isFailed(event2.ResourceStatus) && event2.ResourceStatusReason ? event2.ResourceStatusReason : ""
              );
              const { [event2.LogicalResourceId]: _, ...next } = previous2;
              return next;
            }
            return {
              ...previous2,
              [payload.properties.event.LogicalResourceId]: payload.properties.event
            };
          });
        });
        return () => {
          bus.unsubscribe(event);
        };
      }, []);
      function color(status) {
        if (stacks_exports.isFailed(status))
          return "red";
        if (stacks_exports.isSuccess(status))
          return "green";
        return "yellow";
      }
      return /* @__PURE__ */ React.createElement(Box, { flexDirection: "column" }, Object.entries(resources).slice(0, process.stdout.rows - 2).map(([_, evt], index) => {
        const readable = logicalIdToCdkPath(
          props.assembly,
          evt.StackName,
          evt.LogicalResourceId
        );
        return /* @__PURE__ */ React.createElement(Box, { key: index }, /* @__PURE__ */ React.createElement(Text, null, /* @__PURE__ */ React.createElement(Spinner, null), "  ", readable ? `${stackNameToId(evt.StackName)} ${readable} ${evt.ResourceType}` : `${stackNameToId(evt.StackName)} ${evt.ResourceType}`, " "), /* @__PURE__ */ React.createElement(Text, { color: color(evt.ResourceStatus || "") }, evt.ResourceStatus));
      }), Object.entries(resources).length === 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Text, null, /* @__PURE__ */ React.createElement(Spinner, null), "  ", /* @__PURE__ */ React.createElement(Text, { dimColor: true }, props.remove ? "Removing..." : "Deploying..."))));
    };
  }
});

// src/pothos.ts
var pothos_exports = {};
__export(pothos_exports, {
  Pothos: () => pothos_exports,
  extractSchema: () => extractSchema,
  generate: () => generate
});
import babel from "@babel/core";
import generator from "@babel/generator";
import esbuild3 from "esbuild";
import fs14 from "fs/promises";
import path16 from "path";
import url9 from "url";
async function generate(opts) {
  const { printSchema, lexicographicSortSchema } = await import("graphql");
  const contents = await extractSchema(opts);
  const out = path16.join(path16.dirname(opts.schema), "out.mjs");
  await fs14.writeFile(out, contents, "utf8");
  const { schema } = await import(url9.pathToFileURL(out).href + "?bust=" + Date.now());
  await fs14.rm(out);
  const schemaAsString = printSchema(lexicographicSortSchema(schema));
  return schemaAsString;
}
async function extractSchema(opts) {
  const result = await esbuild3.build({
    platform: "node",
    bundle: true,
    format: "esm",
    entryPoints: [opts.schema],
    external: ["@pothos/*"],
    keepNames: true,
    write: false,
    plugins: [
      {
        name: "externalize",
        setup(build2) {
          const filter = /^[^.\/]|^\.[^.\/]|^\.\.[^\/]/;
          build2.onResolve({ filter }, (args) => {
            return {
              path: args.path,
              external: true
            };
          });
        }
      }
    ]
  });
  const globalPaths = /* @__PURE__ */ new Set();
  const transformed = babel.transformSync(result.outputFiles[0].text, {
    sourceType: "module",
    plugins: [
      {
        name: "pothos-extractor",
        visitor: {
          Program(path20) {
            const dummyResolverId = path20.scope.generateUidIdentifier("DUMMY_RESOLVER");
            const resolverNode = dummyResolver({
              dummy_resolver: dummyResolverId
            });
            path20.unshiftContainer("body", resolverNode);
            path20.scope.crawl();
            let schemaBuilder = null;
            path20.traverse({
              ImportDeclaration(declarator) {
                if (!declarator)
                  return;
                if (declarator.node.source.value.startsWith("@pothos"))
                  return;
                declarator.remove();
              },
              VariableDeclarator(declarator) {
                if (schemaBuilder)
                  return;
                const init = declarator.get("init");
                if (init.isNewExpression() && init.get("callee").referencesImport("@pothos/core", "default")) {
                  schemaBuilder = declarator;
                }
              },
              CallExpression(callPath) {
                if (!types.isMemberExpression(callPath.node.callee) || !types.isIdentifier(callPath.node.callee.object) || !types.isIdentifier(callPath.node.callee.property) || !schemaBuilder || callPath.node.callee.object.name !== schemaBuilder.node.id.name && callPath.node.callee.property.name !== "implement") {
                  return;
                }
                callPath.traverse({
                  Property(propertyPath) {
                    if (types.isIdentifier(propertyPath.node.key) && ["resolve", "validate"].includes(
                      propertyPath.node.key.name
                    )) {
                      propertyPath.remove();
                    }
                  }
                });
                if (callPath.node.callee.property.name === "addScalarType" || callPath.node.callee.property.name === "scalarType") {
                  callPath.node.callee.property = types.identifier("scalarType");
                  callPath.node.arguments = [
                    callPath.node.arguments[0],
                    dummyResolverId
                  ];
                }
                const bindings = getBindings(callPath, globalPaths);
                for (const binding of bindings) {
                  globalPaths.add(findRootBinding(binding).node);
                }
                globalPaths.add(findRootBinding(callPath).node);
              },
              ExportDeclaration(exportPath) {
                globalPaths.add(exportPath.node);
              }
            });
          }
        }
      }
    ]
  });
  if (!transformed)
    throw new Error("Could not transform file");
  const contents = generator.default(
    types.program([...globalPaths])
  );
  return contents.code;
}
function getBindings(path20, globalPaths) {
  const bindings = [];
  path20.traverse({
    Expression(expressionPath) {
      if (!expressionPath.isIdentifier())
        return;
      const binding = path20.scope.getBinding(expressionPath);
      if (!binding || globalPaths.has(binding.path) || bindings.includes(binding.path))
        return;
      const rootBinding = findRootBinding(binding.path);
      if (path20 === rootBinding) {
        bindings.push(binding.path);
        return;
      }
      const bindingOfBindings = getBindings(rootBinding, globalPaths);
      bindings.push(...bindingOfBindings, binding.path);
    }
  });
  for (const binding of bindings) {
    globalPaths.add(findRootBinding(binding).node);
  }
  return bindings;
}
function findRootBinding(path20) {
  let rootPath = path20;
  while (rootPath.parentPath?.node !== void 0 && !rootPath.parentPath?.isProgram()) {
    rootPath = rootPath.parentPath;
  }
  return rootPath;
}
var types, template, dummyResolver;
var init_pothos = __esm({
  "src/pothos.ts"() {
    "use strict";
    init_pothos();
    ({ types, template } = babel);
    dummyResolver = template(
      "const %%dummy_resolver%% = { serialize: x => x, parseValue: x => x  };"
    );
  }
});

// src/cli/commands/plugins/pothos.ts
var pothos_exports2 = {};
__export(pothos_exports2, {
  usePothosBuilder: () => usePothosBuilder
});
import fs15 from "fs/promises";
import { exec as exec6 } from "child_process";
import { promisify as promisify4 } from "util";
import path17 from "path";
var execAsync4, usePothosBuilder;
var init_pothos2 = __esm({
  "src/cli/commands/plugins/pothos.ts"() {
    "use strict";
    init_bus();
    init_context();
    init_pothos();
    init_colors();
    execAsync4 = promisify4(exec6);
    usePothosBuilder = Context.memo(() => {
      let routes = [];
      const bus = useBus();
      async function build2(route) {
        try {
          const schema = await pothos_exports.generate({
            schema: route.schema
          });
          await fs15.writeFile(route.output, schema);
          if (Array.isArray(route.commands) && route.commands.length > 0) {
            await Promise.all(route.commands.map((cmd) => execAsync4(cmd)));
          }
          Colors.line(Colors.success(`\u2714`), " Pothos: Extracted pothos schema");
        } catch (ex) {
          Colors.line(Colors.danger(`\u2716`), " Pothos: Failed to extract schema:");
          for (let line of ex.message.split("\n")) {
            console.log(`  `, line);
          }
        }
      }
      bus.subscribe("file.changed", async (evt) => {
        if (evt.properties.file.endsWith("out.mjs"))
          return;
        for (const route of routes) {
          const dir = path17.dirname(route.schema);
          const relative = path17.relative(dir, evt.properties.file);
          if (relative && !relative.startsWith("..") && !path17.isAbsolute(relative))
            build2(route);
        }
      });
      let first = false;
      bus.subscribe("stacks.metadata", async (evt) => {
        routes = Object.values(evt.properties).flat().filter((c) => c.type == "Api").flatMap((c) => c.data.routes).filter((r) => ["pothos", "graphql"].includes(r.type)).filter((r) => r.schema);
        if (first)
          return;
        for (const route of routes) {
          build2(route);
          first = true;
        }
      });
    });
  }
});

// src/cli/commands/plugins/kysely.ts
var kysely_exports = {};
__export(kysely_exports, {
  useKyselyTypeGenerator: () => useKyselyTypeGenerator
});
import { Kysely } from "kysely";
import { DataApiDialect } from "kysely-data-api";
import { RDSData } from "@aws-sdk/client-rds-data";
import * as fs16 from "fs/promises";
import {
  DatabaseMetadata,
  EnumCollection,
  PostgresDialect,
  MysqlDialect,
  Serializer,
  Transformer
} from "kysely-codegen";
var useKyselyTypeGenerator;
var init_kysely = __esm({
  "src/cli/commands/plugins/kysely.ts"() {
    "use strict";
    init_context();
    init_bus();
    init_logger();
    init_credentials();
    useKyselyTypeGenerator = Context.memo(async () => {
      let databases = [];
      const bus = useBus();
      const logger = Logger.debug.bind(null, "[kysely-codegen]");
      async function generate2(db) {
        if (!db.types)
          return;
        logger("generating types for", db.migratorID);
        const k = new Kysely({
          dialect: new DataApiDialect({
            mode: db.engine.includes("postgres") ? "postgres" : "mysql",
            driver: {
              secretArn: db.secretArn,
              resourceArn: db.clusterArn,
              database: db.defaultDatabaseName,
              client: useAWSClient(RDSData)
            }
          })
        });
        const tables = await k.introspection.getTables();
        logger("introspected tables");
        const metadata3 = db.engine.includes("postgres") ? tables.map((table) => ({
          ...table,
          columns: table.columns.map((column) => {
            const isArray = column.dataType.startsWith("_");
            return {
              ...column,
              dataType: isArray ? column.dataType.slice(1) : column.dataType,
              enumValues: null,
              isArray
            };
          })
        })) : tables.map((table) => ({
          ...table,
          columns: table.columns.map((column) => ({
            ...column,
            enumValues: null
          }))
        }));
        logger("generated metadata", metadata3.length);
        const transformer = new Transformer();
        const Dialect = db.engine.includes("postgres") ? new PostgresDialect() : new MysqlDialect();
        const nodes = transformer.transform({
          dialect: Dialect,
          camelCase: db.types.camelCase === true,
          metadata: new DatabaseMetadata(metadata3, new EnumCollection())
        });
        logger("transformed nodes", nodes.length);
        const lastIndex = nodes.length - 1;
        const last2 = nodes[lastIndex];
        nodes[lastIndex] = {
          ...last2,
          argument: {
            ...last2.argument,
            name: "Database"
          }
        };
        const serializer = new Serializer();
        const data2 = serializer.serialize(nodes);
        await fs16.writeFile(db.types.path, data2);
      }
      bus.subscribe("stacks.metadata", (evt) => {
        const constructs = Object.values(evt.properties).flat();
        databases = constructs.filter((c) => c.type === "RDS").filter((c) => c.data.migrator).filter((c) => c.data.types).map((c) => ({
          migratorID: constructs.find(
            (fn) => fn.addr == c.data.migrator?.node
          ).addr,
          clusterArn: c.data.clusterArn,
          types: c.data.types,
          engine: c.data.engine,
          defaultDatabaseName: c.data.defaultDatabaseName,
          secretArn: c.data.secretArn
        }));
        databases.map(
          (db) => generate2(db).catch((err) => {
            logger(err);
          })
        );
      });
      bus.subscribe("function.success", async (evt) => {
        if (!evt.properties.body?.results)
          return;
        const db = databases.find(
          (db2) => db2.migratorID === evt.properties.functionID
        );
        if (!db)
          return;
        generate2(db).catch((err) => {
          logger(err);
        });
      });
      logger("Loaded kyseley type generator");
    });
  }
});

// src/cli/commands/plugins/warmer.ts
var warmer_exports = {};
__export(warmer_exports, {
  useRDSWarmer: () => useRDSWarmer
});
import {
  RDSDataClient,
  ExecuteStatementCommand
} from "@aws-sdk/client-rds-data";
var useRDSWarmer;
var init_warmer = __esm({
  "src/cli/commands/plugins/warmer.ts"() {
    "use strict";
    init_bus();
    init_context();
    init_credentials();
    useRDSWarmer = Context.memo(async () => {
      let interval;
      const bus = useBus();
      const client = useAWSClient(RDSDataClient);
      bus.subscribe("stacks.metadata", (evt) => {
        if (interval)
          clearInterval(interval);
        interval = setInterval(() => {
          Object.values(evt.properties).flat().filter((c) => c.type === "RDS").map((c) => {
            try {
              client.send(
                new ExecuteStatementCommand({
                  sql: "SELECT 1",
                  secretArn: c.data.secretArn,
                  resourceArn: c.data.clusterArn,
                  database: c.data.defaultDatabaseName
                })
              );
            } catch (e) {
            }
          });
        }, 1e3 * 60);
      });
    });
  }
});

// src/cli/terminal.ts
var terminal_exports = {};
__export(terminal_exports, {
  clear: () => clear
});
function clear() {
  for (let i = 0, l = process.stdout.rows; i < l - 1; i++) {
    console.log("");
  }
  console.clear();
}
var init_terminal = __esm({
  "src/cli/terminal.ts"() {
    "use strict";
  }
});

// src/config.ts
var config_exports = {};
__export(config_exports, {
  Config: () => Config
});
import {
  DeleteParameterCommand,
  GetParameterCommand,
  GetParametersByPathCommand,
  PutParameterCommand,
  SSMClient
} from "@aws-sdk/client-ssm";
import {
  GetFunctionConfigurationCommand,
  LambdaClient,
  UpdateFunctionConfigurationCommand
} from "@aws-sdk/client-lambda";
import { pipe as pipe2, map as map2 } from "remeda";
async function* scan(prefix) {
  const ssm = useAWSClient(SSMClient);
  let token;
  while (true) {
    const results = await ssm.send(
      new GetParametersByPathCommand({
        Path: prefix,
        WithDecryption: true,
        Recursive: true,
        NextToken: token
      })
    );
    yield* results.Parameters || [];
    if (!results.NextToken)
      break;
    token = results.NextToken;
  }
}
function parse(ssmName, prefix) {
  const parts = ssmName.substring(prefix.length).split("/");
  return {
    type: parts[0],
    id: parts[1],
    prop: parts.slice(2).join("/")
  };
}
async function restartFunction(arn) {
  const lambda = useAWSClient(LambdaClient);
  try {
    const config = await lambda.send(
      new GetFunctionConfigurationCommand({
        FunctionName: arn
      })
    );
    await lambda.send(
      new UpdateFunctionConfigurationCommand({
        FunctionName: arn,
        Environment: {
          Variables: {
            ...config.Environment?.Variables || {},
            [SECRET_UPDATED_AT_ENV]: Date.now().toString()
          }
        }
      })
    );
    return true;
  } catch (e) {
    if (e.name === "ResourceNotFoundException" && e.message.startsWith("Function not found")) {
      return;
    }
  }
}
var Config, FALLBACK_STAGE, SECRET_UPDATED_AT_ENV, PREFIX;
var init_config = __esm({
  "src/config.ts"() {
    "use strict";
    init_project();
    init_credentials();
    init_iot();
    init_stacks();
    ((Config2) => {
      async function parameters() {
        const result = [];
        for await (const p of scan(PREFIX.FALLBACK)) {
          const parsed = parse(p.Name, PREFIX.FALLBACK);
          if (parsed.type === "secrets")
            continue;
          result.push({
            ...parsed,
            value: p.Value
          });
        }
        for await (const p of scan(PREFIX.STAGE)) {
          const parsed = parse(p.Name, PREFIX.STAGE);
          if (parsed.type === "secrets")
            continue;
          result.push({
            ...parsed,
            value: p.Value
          });
        }
        return result;
      }
      Config2.parameters = parameters;
      function envFor(input) {
        return `SST_${input.type}_${input.prop}_${normalizeID(input.id)}`;
      }
      Config2.envFor = envFor;
      function pathFor(input) {
        return `${input.fallback ? PREFIX.FALLBACK : PREFIX.STAGE}${input.type}/${normalizeID(input.id)}/${input.prop}`;
      }
      Config2.pathFor = pathFor;
      function normalizeID(input) {
        return input.replace(/-/g, "_");
      }
      Config2.normalizeID = normalizeID;
      async function secrets2() {
        const result = {};
        for await (const p of scan(PREFIX.STAGE + "Secret")) {
          const parsed = parse(p.Name, PREFIX.STAGE);
          if (!result[parsed.id])
            result[parsed.id] = {};
          result[parsed.id].value = p.Value;
        }
        for await (const p of scan(PREFIX.FALLBACK + "Secret")) {
          const parsed = parse(p.Name, PREFIX.FALLBACK);
          if (!result[parsed.id])
            result[parsed.id] = {};
          result[parsed.id].fallback = p.Value;
        }
        return result;
      }
      Config2.secrets = secrets2;
      async function env() {
        const project = useProject();
        const parameters2 = await Config2.parameters();
        const env2 = {
          SST_APP: project.config.name,
          SST_STAGE: project.config.stage,
          ...pipe2(
            parameters2,
            map2((p) => [envFor(p), p.value]),
            Object.fromEntries
          )
        };
        return env2;
      }
      Config2.env = env;
      async function setSecret(input) {
        const ssm = useAWSClient(SSMClient);
        await ssm.send(
          new PutParameterCommand({
            Name: pathFor({
              id: input.key,
              type: "Secret",
              prop: "value",
              fallback: input.fallback
            }),
            Value: input.value,
            Type: "SecureString",
            Overwrite: true
          })
        );
        const iot2 = await useIOT();
        const topic = `${iot2.prefix}/events`;
        await iot2.publish(topic, "config.secret.updated", { name: input.key });
      }
      Config2.setSecret = setSecret;
      async function getSecret(input) {
        const ssm = useAWSClient(SSMClient);
        const result = await ssm.send(
          new GetParameterCommand({
            Name: pathFor({
              id: input.key,
              prop: "value",
              type: "Secret",
              fallback: input.fallback
            }),
            WithDecryption: true
          })
        );
        return result.Parameter?.Value;
      }
      Config2.getSecret = getSecret;
      async function removeSecret(input) {
        const ssm = useAWSClient(SSMClient);
        await ssm.send(
          new DeleteParameterCommand({
            Name: pathFor({
              id: input.key,
              type: "Secret",
              prop: "value",
              fallback: input.fallback
            })
          })
        );
      }
      Config2.removeSecret = removeSecret;
      async function restart(keys) {
        const metadata3 = await stacks_exports.metadata();
        const siteData = Object.values(metadata3).flat().filter(
          (c) => c.type === "AstroSite" || c.type === "NextjsSite" || c.type === "RemixSite" || c.type === "SolidStartSite"
        ).filter((c) => keys.some((key) => c.data.secrets.includes(key)));
        const siteDataPlaceholder = siteData.filter(
          (c) => c.data.mode === "placeholder"
        );
        const siteDataEdge = siteData.filter((c) => c.data.mode === "deployed").filter((c) => c.data.edge);
        const siteDataRegional = siteData.filter((c) => c.data.mode === "deployed").filter((c) => !c.data.edge);
        const regionalSiteArns = siteData.map((s) => s.data.server);
        const functionData = Object.values(metadata3).flat().filter((c) => c.type === "Function").filter((c) => !regionalSiteArns.includes(c.data.arn)).filter((c) => keys.some((key) => c.data.secrets.includes(key)));
        const restartedSites = (await Promise.all(
          siteDataRegional.map(async (s) => {
            const restarted = await restartFunction(s.data.server);
            return restarted ? s : restarted;
          })
        )).filter((c) => Boolean(c));
        const restartedFunctions = (await Promise.all(
          functionData.map(async (f) => {
            const restarted = await restartFunction(f.data.arn);
            return restarted ? f : restarted;
          })
        )).filter((c) => Boolean(c));
        return {
          edgeSites: siteDataEdge,
          sites: restartedSites,
          placeholderSites: siteDataPlaceholder,
          functions: restartedFunctions
        };
      }
      Config2.restart = restart;
    })(Config || (Config = {}));
    FALLBACK_STAGE = ".fallback";
    SECRET_UPDATED_AT_ENV = "SST_ADMIN_SECRET_UPDATED_AT";
    PREFIX = {
      get STAGE() {
        const project = useProject();
        return project.config.ssmPrefix;
      },
      get FALLBACK() {
        const project = useProject();
        return `/sst/${project.config.name}/${FALLBACK_STAGE}/`;
      }
    };
  }
});

// src/cli/sst.ts
import { blue as blue3, red } from "colorette";

// src/cli/program.ts
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
var program = yargs(hideBin(process.argv)).scriptName("sst").option("stage", {
  type: "string",
  describe: "The stage to use, defaults to personal stage"
}).option("profile", {
  type: "string",
  describe: "The AWS profile to use"
}).option("region", {
  type: "string",
  describe: "The AWS region to use"
}).option("verbose", {
  type: "boolean",
  describe: "Print verbose logs"
}).option("role", {
  type: "string",
  describe: "ARN of the IAM role to use when invoking AWS"
}).group(["stage", "profile", "region", "role", "verbose", "help"], "Global:").middleware(async (argv) => {
  if (argv.verbose) {
    process.env.SST_VERBOSE = "1";
  }
  if (argv._.length > 0) {
    const { initProject: initProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    await initProject2(argv);
    const { trackCli: trackCli2 } = await Promise.resolve().then(() => (init_telemetry(), telemetry_exports));
    trackCli2(argv._[0]);
  }
}).version(false).epilogue(`Join the SST community on Discord https://sst.dev/discord`).recommendCommands().demandCommand().strict().fail((_, error2, yargs2) => {
  if (!error2) {
    yargs2.showHelp();
    process.exit(1);
  }
  throw error2;
});

// src/cli/sst.ts
init_error();
init_spinner();
init_logger();
import dotenv2 from "dotenv";

// src/cli/commands/bootstrap.ts
var bootstrap = (program2) => program2.command(
  "bootstrap",
  "Create the SST bootstrap stack",
  (yargs2) => yargs2,
  async () => {
    const { useBootstrap: useBootstrap2 } = await Promise.resolve().then(() => (init_bootstrap(), bootstrap_exports));
    await useBootstrap2();
    process.exit(0);
  }
);

// src/cli/commands/dev.tsx
var dev = (program2) => program2.command(
  ["dev", "start"],
  "Work on your app locally",
  (yargs2) => yargs2.option("increase-timeout", {
    type: "boolean",
    description: "Increase function timeout"
  }),
  async (args) => {
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const { printHeader: printHeader2 } = await Promise.resolve().then(() => (init_header(), header_exports));
    const { mapValues } = await import("remeda");
    const path20 = await import("path");
    const { useRuntimeWorkers: useRuntimeWorkers2 } = await Promise.resolve().then(() => (init_workers(), workers_exports));
    const { useIOTBridge: useIOTBridge2 } = await Promise.resolve().then(() => (init_iot2(), iot_exports2));
    const { useRuntimeServer: useRuntimeServer2 } = await Promise.resolve().then(() => (init_server(), server_exports));
    const { useBus: useBus2 } = await Promise.resolve().then(() => (init_bus(), bus_exports));
    const { useWatcher: useWatcher2 } = await Promise.resolve().then(() => (init_watcher(), watcher_exports));
    const { useAppMetadata: useAppMetadata2, saveAppMetadata: saveAppMetadata2, Stacks } = await Promise.resolve().then(() => (init_stacks(), stacks_exports));
    const { Logger: Logger2 } = await Promise.resolve().then(() => (init_logger(), logger_exports));
    const { createSpinner: createSpinner2 } = await Promise.resolve().then(() => (init_spinner(), spinner_exports));
    const { bold: bold2, dim: dim2, yellow } = await import("colorette");
    const { render } = await import("ink");
    const React2 = await import("react");
    const { Context: Context2 } = await Promise.resolve().then(() => (init_context(), context_exports));
    const { printDeploymentResults: printDeploymentResults2, DeploymentUI: DeploymentUI2 } = await Promise.resolve().then(() => (init_deploy2(), deploy_exports));
    const { useLocalServer: useLocalServer2 } = await Promise.resolve().then(() => (init_server2(), server_exports2));
    const fs18 = await import("fs/promises");
    const crypto2 = await import("crypto");
    const { useFunctions: useFunctions3 } = await import("../src/constructs/Function.js");
    const { useSites } = await import("../src/constructs/SsrSite.js");
    const { usePothosBuilder: usePothosBuilder2 } = await Promise.resolve().then(() => (init_pothos2(), pothos_exports2));
    const { useKyselyTypeGenerator: useKyselyTypeGenerator2 } = await Promise.resolve().then(() => (init_kysely(), kysely_exports));
    const { useRDSWarmer: useRDSWarmer2 } = await Promise.resolve().then(() => (init_warmer(), warmer_exports));
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { useMetadata: useMetadata2 } = await Promise.resolve().then(() => (init_metadata(), metadata_exports));
    const { useIOT: useIOT2 } = await Promise.resolve().then(() => (init_iot(), iot_exports));
    const { clear: clear2 } = await Promise.resolve().then(() => (init_terminal(), terminal_exports));
    const { getCiInfo: getCiInfo2 } = await Promise.resolve().then(() => (init_ci_info(), ci_info_exports));
    if (args._[0] === "start") {
      console.log(
        yellow(
          `Warning: ${bold2(`sst start`)} has been renamed to ${bold2(
            `sst dev`
          )}`
        )
      );
    }
    const useFunctionLogger = Context2.memo(async () => {
      const bus = useBus2();
      const colors = ["#01cdfe", "#ff71ce", "#05ffa1", "#b967ff"];
      let index = 0;
      const pending = /* @__PURE__ */ new Map();
      function prefix(requestID) {
        const exists = pending.get(requestID);
        if (exists) {
          return Colors2.hex(exists.color)(Colors2.prefix);
        }
        pending.set(requestID, {
          requestID,
          started: Date.now(),
          color: colors[index % colors.length]
        });
        index++;
        return prefix(requestID);
      }
      function end(requestID) {
        pending.delete(requestID);
      }
      bus.subscribe("function.invoked", async (evt) => {
        Colors2.line(
          prefix(evt.properties.requestID),
          Colors2.dim.bold("Invoked"),
          Colors2.dim(
            useFunctions3().fromID(evt.properties.functionID)?.handler
          )
        );
      });
      bus.subscribe("worker.stdout", async (evt) => {
        prefix(evt.properties.requestID);
        const { started } = pending.get(evt.properties.requestID);
        for (let line of evt.properties.message.split("\n")) {
          Colors2.line(
            prefix(evt.properties.requestID),
            Colors2.dim(("+" + (Date.now() - started) + "ms").padEnd(7)),
            Colors2.dim(line)
          );
        }
      });
      bus.subscribe("function.build.success", async (evt) => {
        const info = useFunctions3().fromID(evt.properties.functionID);
        if (!info)
          return;
        if (info.enableLiveDev === false)
          return;
        Colors2.line(Colors2.dim(Colors2.prefix, "Built", info.handler));
      });
      bus.subscribe("function.build.failed", async (evt) => {
        const info = useFunctions3().fromID(evt.properties.functionID);
        if (!info)
          return;
        if (info.enableLiveDev === false)
          return;
        Colors2.gap();
        Colors2.line(Colors2.danger("\u2716 "), "Build failed", info.handler);
        for (const line of evt.properties.errors) {
          Colors2.line("  ", line);
        }
        Colors2.gap();
      });
      bus.subscribe("function.success", async (evt) => {
        const p = prefix(evt.properties.requestID);
        const req = pending.get(evt.properties.requestID);
        setTimeout(() => {
          Colors2.line(
            p,
            Colors2.dim(`Done in ${Date.now() - req.started - 100}ms`)
          );
          end(evt.properties.requestID);
        }, 100);
      });
      bus.subscribe("function.error", async (evt) => {
        setTimeout(() => {
          Colors2.line(
            prefix(evt.properties.requestID),
            Colors2.danger.bold("Error:"),
            Colors2.danger.bold(evt.properties.errorMessage)
          );
          for (const line of evt.properties.trace || []) {
            if (line.includes(evt.properties.errorMessage))
              continue;
            Colors2.line("  ", `${dim2(line)}`);
          }
          end(evt.properties.requestID);
        }, 100);
      });
    });
    const useStackBuilder = Context2.memo(async () => {
      const watcher = useWatcher2();
      const project = useProject2();
      let lastDeployed;
      let isWorking = false;
      let isDirty = false;
      async function build2() {
        if (isWorking) {
          isDirty = true;
          return;
        }
        isDirty = false;
        isWorking = true;
        Colors2.gap();
        const spinner = createSpinner2({
          color: "gray",
          text: lastDeployed ? ` Building...` : dim2(` Checking for changes`)
        }).start();
        try {
          const [metafile, sstConfig] = await Stacks.load(
            project.paths.config
          );
          project.metafile = metafile;
          project.stacks = sstConfig.stacks;
          const assembly = await Stacks.synth({
            increaseTimeout: args["increase-timeout"],
            fn: project.stacks,
            outDir: `.sst/cdk.out`,
            mode: "dev"
          });
          Logger2.debug("Directory", assembly.directory);
          const next = await checksum(assembly.directory);
          Logger2.debug("Checksum", "next", next, "old", lastDeployed);
          if (next === lastDeployed) {
            spinner.succeed(Colors2.dim(" Built with no changes"));
            isWorking = false;
            if (isDirty)
              build2();
            return;
          }
          if (!lastDeployed) {
            spinner.stop();
            spinner.clear();
            Colors2.mode("gap");
          } else {
            spinner.succeed(Colors2.dim(` Built`));
            Colors2.gap();
          }
          deploy3(assembly);
        } catch (ex) {
          isWorking = false;
          spinner.fail();
          Colors2.line(
            ex.stack.split("\n").map((line) => "   " + line).join("\n")
          );
          Colors2.gap();
        }
      }
      async function deploy3(assembly) {
        const nextChecksum = await checksum(assembly.directory);
        const component = render(/* @__PURE__ */ React2.createElement(DeploymentUI2, { assembly }));
        const results = await Stacks.deployMany(assembly.stacks);
        component.clear();
        component.unmount();
        printDeploymentResults2(assembly, results);
        if (!lastDeployed) {
          await saveAppMetadata2({ mode: "dev" });
          useSites().all.filter(({ props }) => props.dev?.deploy !== true).forEach(({ type, props }) => {
            const framework = type === "AstroSite" ? "Astro" : type === "NextjsSite" ? "Next.js" : type === "RemixSite" ? "Remix" : type === "SolidStartSite" ? "SolidStart" : void 0;
            if (framework) {
              const cdCmd = path20.resolve(props.path) === process.cwd() ? "" : `cd ${props.path} && `;
              Colors2.line(
                Colors2.primary(`\u279C `),
                Colors2.bold(`Start ${framework}:`),
                `${cdCmd}npm run dev`
              );
              Colors2.gap();
            }
          });
        }
        lastDeployed = nextChecksum;
        fs18.writeFile(
          path20.join(project.paths.out, "outputs.json"),
          JSON.stringify(
            mapValues(results, (val) => val.outputs),
            null,
            2
          )
        );
        isWorking = false;
        if (isDirty)
          build2();
      }
      async function checksum(cdkOutPath) {
        const manifestPath = path20.join(cdkOutPath, "manifest.json");
        const cdkManifest = JSON.parse(
          await fs18.readFile(manifestPath).then((x) => x.toString())
        );
        const checksumData = await Promise.all(
          Object.keys(cdkManifest.artifacts).filter(
            (key) => cdkManifest.artifacts[key].type === "aws:cloudformation:stack"
          ).map(async (key) => {
            const { templateFile } = cdkManifest.artifacts[key].properties;
            const templatePath = path20.join(cdkOutPath, templateFile);
            const templateContent = await fs18.readFile(templatePath);
            return templateContent;
          })
        ).then((x) => x.join("\n"));
        const hash2 = crypto2.createHash("sha256").update(checksumData).digest("hex");
        return hash2;
      }
      watcher.subscribe("file.changed", async (evt) => {
        if (!project.metafile)
          return;
        if (!project.metafile.inputs[evt.properties.relative.split(path20.sep).join(path20.posix.sep)])
          return;
        build2();
      });
      await build2();
    });
    const useDisconnector = Context2.memo(async () => {
      const bus = useBus2();
      const project = useProject2();
      const iot2 = await useIOT2();
      bus.subscribe("cli.dev", async (evt) => {
        const topic = `${iot2.prefix}/events`;
        iot2.publish(topic, "cli.dev", evt.properties);
      });
      bus.publish("cli.dev", {
        stage: project.config.stage,
        app: project.config.name
      });
      bus.subscribe("cli.dev", async (evt) => {
        if (evt.properties.stage !== project.config.stage)
          return;
        if (evt.properties.app !== project.config.name)
          return;
        Colors2.gap();
        Colors2.line(
          Colors2.danger(`\u279C `),
          "Another `sst dev` session has been started for this stage. Exiting..."
        );
        process.exit(0);
      });
    });
    const [appMetadata] = await Promise.all([
      useAppMetadata2(),
      useLocalServer2({
        key: "",
        cert: "",
        live: true
      })
    ]);
    async function promptChangeMode() {
      const readline = await import("readline");
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
      return new Promise((resolve) => {
        console.log("");
        rl.question(
          `You have previously deployed the stage "${useProject2().config.stage}" in production. It is recommended that you use a different stage for development. Read more here \u2014 https://docs.sst.dev/live-lambda-development

Are you sure you want to run this stage in dev mode? [y/N] `,
          async (input) => {
            rl.close();
            resolve(input.trim() === "y");
          }
        );
      });
    }
    if (!getCiInfo2().isCI && appMetadata && appMetadata.mode !== "dev") {
      if (!await promptChangeMode()) {
        process.exit(0);
      }
    }
    clear2();
    await printHeader2({ console: true, hint: "ready!" });
    await Promise.all([
      useDisconnector(),
      useRuntimeWorkers2(),
      useIOTBridge2(),
      useRuntimeServer2(),
      usePothosBuilder2(),
      useMetadata2(),
      useKyselyTypeGenerator2(),
      useRDSWarmer2(),
      useFunctionLogger(),
      useStackBuilder()
    ]);
  }
);

// src/cli/commands/bind.ts
init_error();
import path18 from "path";
var OutdatedMetadataError = class extends Error {
};
var bind = (program2) => program2.command(
  ["bind <command..>", "env <command..>"],
  "Bind your app's resources to a command",
  (yargs2) => yargs2.array("command").example(`sst bind "vitest run"`, "Bind your resources to your tests").example(
    `sst bind "tsx scripts/myscript.ts"`,
    "Bind your resources to a script"
  ),
  async (args) => {
    const { spawn: spawn7 } = await import("child_process");
    const kill = await import("tree-kill");
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { useBus: useBus2 } = await Promise.resolve().then(() => (init_bus(), bus_exports));
    const { useIOT: useIOT2 } = await Promise.resolve().then(() => (init_iot(), iot_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const { Logger: Logger2 } = await Promise.resolve().then(() => (init_logger(), logger_exports));
    if (args._[0] === "env") {
      Colors2.line(
        Colors2.warning(
          `Warning: ${Colors2.bold(
            `sst env`
          )} has been renamed to ${Colors2.bold(`sst bind`)}`
        )
      );
    }
    await useIOT2();
    const bus = useBus2();
    const project = useProject2();
    const command = args.command?.join(" ");
    const isSite = await isRunningInSite();
    let p;
    let timer;
    let siteConfigCache;
    if (!command) {
      throw new VisibleError(
        `Command is required, e.g. sst bind ${isSite ? "next dev" : "vitest run"}`
      );
    }
    if (!isSite) {
      Logger2.debug("Running in script mode.");
      return await bindScript();
    }
    try {
      await bindSite("init");
    } catch (e) {
      if (e instanceof OutdatedMetadataError) {
        Colors2.line(
          Colors2.warning(
            "Warning: This was deployed with an old version of SST. Run `sst dev` or `sst deploy` to update."
          )
        );
        return await bindScript();
      }
      throw e;
    }
    bus.subscribe(
      "stacks.metadata.updated",
      () => bindSite("metadata_updated")
    );
    bus.subscribe(
      "stacks.metadata.deleted",
      () => bindSite("metadata_updated")
    );
    bus.subscribe("config.secret.updated", (payload) => {
      const secretName = payload.properties.name;
      if (!(siteConfigCache?.secrets || []).includes(secretName))
        return;
      Colors2.line(
        `
`,
        `SST secrets have been updated. Restarting \`${command}\`...`
      );
      bindSite("secrets_updated");
    });
    async function isRunningInSite() {
      const { existsAsync: existsAsync3 } = await Promise.resolve().then(() => (init_fs(), fs_exports));
      const { readFile } = await import("fs/promises");
      const SITE_CONFIGS = [
        { file: "next.config", multiExtension: true },
        { file: "astro.config", multiExtension: true },
        { file: "remix.config", multiExtension: true },
        { file: "svelte.config", multiExtension: true },
        { file: "gatsby-config", multiExtension: true },
        { file: "angular.json" },
        { file: "ember-cli-build.js" },
        {
          file: "vite.config",
          multiExtension: true,
          match: /solid-start|plugin-vue|plugin-react|@preact\/preset-vite/
        },
        { file: "package.json", match: /react-scripts/ },
        { file: "index.html" }
      ];
      const results = await Promise.all(
        SITE_CONFIGS.map((site) => {
          const files = site.multiExtension ? [".js", ".cjs", ".mjs", ".ts"].map(
            (ext) => `${site.file}${ext}`
          ) : [site.file];
          return files.map(async (file) => {
            const exists = await existsAsync3(file);
            if (!exists)
              return false;
            if (site.match) {
              const content = await readFile(file);
              return content.toString().match(site.match);
            }
            return true;
          });
        }).flat()
      );
      return results.some(Boolean);
    }
    async function bindSite(reason) {
      const siteMetadata = await getSiteMetadataUntilAvailable();
      const siteConfig = await parseSiteMetadata(siteMetadata);
      if (reason === "metadata_updated") {
        if (areEnvsSame(siteConfig.envs, siteConfigCache?.envs || {}))
          return;
        Colors2.line(
          `
`,
          `SST resources have been updated. Restarting \`${command}\`...`
        );
      }
      siteConfigCache = siteConfig;
      if (siteConfig.role) {
        const credentials = await assumeSsrRole(siteConfig.role);
        if (credentials) {
          const expireAt = credentials.Expiration.getTime() - 6e4;
          clearTimeout(timer);
          timer = setTimeout(() => {
            Colors2.line(
              `
`,
              `Your AWS session is about to expire. Creating a new session and restarting \`${command}\`...`
            );
            bindSite("iam_expired");
          }, expireAt - Date.now());
          await runCommand({
            ...siteConfig.envs,
            AWS_ACCESS_KEY_ID: credentials.AccessKeyId,
            AWS_SECRET_ACCESS_KEY: credentials.SecretAccessKey,
            AWS_SESSION_TOKEN: credentials.SessionToken
          });
          return;
        }
      }
      await runCommand({
        ...siteConfig.envs,
        ...await localIamCredentials()
      });
    }
    async function bindScript() {
      const { Config: Config2 } = await Promise.resolve().then(() => (init_config(), config_exports));
      await runCommand({
        ...await Config2.env(),
        ...await localIamCredentials()
      });
    }
    async function getSiteMetadataUntilAvailable() {
      const { createSpinner: createSpinner2 } = await Promise.resolve().then(() => (init_spinner(), spinner_exports));
      const spinner = createSpinner2({});
      while (true) {
        const data2 = await getSiteMetadata();
        if (!data2) {
          spinner.start("Make sure `sst dev` is running...");
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          continue;
        }
        spinner.isSpinning && spinner.stop().clear();
        return data2;
      }
    }
    async function getSiteMetadata() {
      const { metadata: metadata3 } = await Promise.resolve().then(() => (init_metadata(), metadata_exports));
      const metadataData = await metadata3();
      return Object.values(metadataData).flat().filter(
        (c) => [
          "StaticSite",
          "NextjsSite",
          "AstroSite",
          "RemixSite",
          "SolidStartSite",
          "SlsNextjsSite"
        ].includes(c.type)
      ).find((c) => {
        const isSsr = c.type !== "StaticSite" && c.type !== "SlsNextjsSite";
        if (!c.data.path || isSsr && !c.data.server || !isSsr && !c.data.environment) {
          throw new OutdatedMetadataError();
        }
        return path18.resolve(project.paths.root, c.data.path) === process.cwd();
      });
    }
    async function parseSiteMetadata(metadata3) {
      const { LambdaClient: LambdaClient2, GetFunctionCommand } = await import("@aws-sdk/client-lambda");
      const { useAWSClient: useAWSClient2 } = await Promise.resolve().then(() => (init_credentials(), credentials_exports));
      const isBindSupported = metadata3.type !== "StaticSite" && metadata3.type !== "SlsNextjsSite";
      if (!isBindSupported) {
        return { envs: metadata3.data.environment };
      }
      const lambda = useAWSClient2(LambdaClient2);
      const { Configuration: functionConfig } = await lambda.send(
        new GetFunctionCommand({
          FunctionName: metadata3.data.server
        })
      );
      return {
        role: functionConfig?.Role,
        envs: functionConfig?.Environment?.Variables || {},
        secrets: metadata3.data.secrets
      };
    }
    async function assumeSsrRole(roleArn) {
      const { STSClient: STSClient2, AssumeRoleCommand } = await import("@aws-sdk/client-sts");
      const { useAWSClient: useAWSClient2 } = await Promise.resolve().then(() => (init_credentials(), credentials_exports));
      const sts = useAWSClient2(STSClient2);
      const assumeRole = async (duration) => {
        const { Credentials: credentials } = await sts.send(
          new AssumeRoleCommand({
            RoleArn: roleArn,
            RoleSessionName: "dev-session",
            DurationSeconds: duration
          })
        );
        return credentials;
      };
      let err;
      try {
        return await assumeRole(43200);
      } catch (e) {
        err = e;
      }
      if (err.name === "ValidationError" && err.message.startsWith("The requested DurationSeconds exceeds")) {
        try {
          return await assumeRole(3600);
        } catch (e) {
          err = e;
        }
      }
      Colors2.line(
        "Using local IAM credentials since `sst dev` is not running."
      );
      Logger2.debug(`Failed to assume ${roleArn}.`, err);
    }
    async function localIamCredentials() {
      const { useAWSCredentials: useAWSCredentials2 } = await Promise.resolve().then(() => (init_credentials(), credentials_exports));
      const credentials = await useAWSCredentials2();
      return {
        AWS_ACCESS_KEY_ID: credentials.accessKeyId,
        AWS_SECRET_ACCESS_KEY: credentials.secretAccessKey,
        AWS_SESSION_TOKEN: credentials.sessionToken
      };
    }
    async function runCommand(envs) {
      Colors2.gap();
      if (p) {
        p.removeAllListeners("exit");
        await new Promise((resolve, reject) => {
          kill.default(p?.pid, (error2) => {
            if (error2) {
              return reject(error2);
            }
            resolve(true);
          });
        });
      }
      p = spawn7(command, {
        env: {
          ...process.env,
          ...envs,
          AWS_REGION: project.config.region
        },
        stdio: "inherit",
        shell: true
      });
      p.on("exit", (code) => {
        process.exit(code || 0);
      });
    }
    function areEnvsSame(envs1, envs2) {
      return Object.keys(envs1).length === Object.keys(envs2).length && Object.keys(envs1).every((key) => envs1[key] === envs2[key]);
    }
  }
).strict(false);

// src/cli/commands/build.ts
var build = (program2) => program2.command(
  "build",
  "Build your app",
  (yargs2) => yargs2.option("to", {
    type: "string",
    describe: "Output directory, defaults to .sst/dist"
  }),
  async (args) => {
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { Stacks } = await Promise.resolve().then(() => (init_stacks(), stacks_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const path20 = await import("path");
    const result = await Stacks.synth({
      fn: useProject2().stacks,
      buildDir: args.to,
      mode: "deploy"
    });
    Colors2.line("");
    Colors2.line(
      Colors2.success(`\u2714`),
      Colors2.bold(" Built:"),
      `${result.stacks.length} stack${result.stacks.length > 1 ? "s" : ""} to ${path20.relative(process.cwd(), result.directory)}`
    );
    process.exit(0);
  }
);

// src/cli/commands/deploy.tsx
init_credentials();
init_colors();
import fs17 from "fs/promises";
import path19 from "path";
var deploy2 = (program2) => program2.command(
  "deploy [filter]",
  "Deploy your app to AWS",
  (yargs2) => yargs2.option("from", {
    type: "string",
    describe: "Deploy using previously built output"
  }).positional("filter", {
    type: "string",
    describe: "Optionally filter stacks to deploy"
  }),
  async (args) => {
    const React2 = await import("react");
    const { printDeploymentResults: printDeploymentResults2 } = await Promise.resolve().then(() => (init_deploy2(), deploy_exports));
    const { createSpinner: createSpinner2 } = await Promise.resolve().then(() => (init_spinner(), spinner_exports));
    const { dim: dim2, blue: blue4, bold: bold2 } = await import("colorette");
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { loadAssembly: loadAssembly2, useAppMetadata: useAppMetadata2, saveAppMetadata: saveAppMetadata2, Stacks } = await Promise.resolve().then(() => (init_stacks(), stacks_exports));
    const { getCiInfo: getCiInfo2 } = await Promise.resolve().then(() => (init_ci_info(), ci_info_exports));
    const { render } = await import("ink");
    const { DeploymentUI: DeploymentUI2 } = await Promise.resolve().then(() => (init_deploy2(), deploy_exports));
    const { mapValues } = await import("remeda");
    const project = useProject2();
    const [identity, appMetadata] = await Promise.all([
      useSTSIdentity(),
      useAppMetadata2()
    ]);
    async function promptChangeMode() {
      const readline = await import("readline");
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
      return new Promise((resolve) => {
        console.log("");
        rl.question(
          `You were previously running the stage "${project.config.stage}" in dev mode. It is recommended that you use a different stage for production. Read more here \u2014 https://docs.sst.dev/live-lambda-development

Are you sure you want to deploy to this stage? (y/N) `,
          async (input) => {
            rl.close();
            resolve(input.trim() === "y");
          }
        );
      });
    }
    if (!getCiInfo2().isCI && appMetadata && appMetadata.mode !== "deploy") {
      if (!await promptChangeMode()) {
        process.exit(0);
      }
    }
    Colors.line(`${Colors.primary.bold(`SST v${project.version}`)}`);
    Colors.gap();
    Colors.line(
      `${Colors.primary(`\u279C`)}  ${Colors.bold("App:")}     ${project.config.name}`
    );
    Colors.line(`   ${Colors.bold("Stage:")}   ${project.config.stage}`);
    Colors.line(`   ${Colors.bold("Region:")}  ${project.config.region}`);
    Colors.line(`   ${Colors.bold("Account:")} ${identity.Account}`);
    Colors.gap();
    const isActiveStack = (stackId) => !args.filter || stackId.toLowerCase().replace(project.config.name.toLowerCase(), "").replace(project.config.stage.toLowerCase(), "").includes(args.filter.toLowerCase());
    const assembly = await async function() {
      if (args.from) {
        const result2 = await loadAssembly2(args.from);
        return result2;
      }
      const spinner = createSpinner2({
        text: " Building..."
      });
      const result = await Stacks.synth({
        fn: project.stacks,
        mode: "deploy",
        isActiveStack
      });
      spinner.succeed();
      return result;
    }();
    const target = assembly.stacks.filter((s) => isActiveStack(s.id));
    if (!target.length) {
      Colors.line(`No stacks found matching ${blue4(args.filter)}`);
      process.exit(1);
    }
    const component = render(/* @__PURE__ */ React2.createElement(DeploymentUI2, { assembly }));
    const results = await Stacks.deployMany(target);
    component.clear();
    component.unmount();
    printDeploymentResults2(assembly, results);
    if (Object.values(results).some((stack) => Stacks.isFailed(stack.status)))
      process.exit(1);
    fs17.writeFile(
      path19.join(project.paths.out, "outputs.json"),
      JSON.stringify(
        mapValues(results, (val) => val.outputs),
        null,
        2
      )
    );
    await saveAppMetadata2({ mode: "deploy" });
    process.exit(0);
  }
);

// src/cli/commands/remove.tsx
var remove2 = (program2) => program2.command(
  "remove [filter]",
  "Remove your app from AWS",
  (yargs2) => yargs2.option("from", { type: "string" }).positional("filter", {
    type: "string",
    describe: "Optionally filter stacks to remove"
  }),
  async (args) => {
    const React2 = await import("react");
    const { dim: dim2, blue: blue4, bold: bold2 } = await import("colorette");
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { loadAssembly: loadAssembly2, clearAppMetadata: clearAppMetadata2, Stacks } = await Promise.resolve().then(() => (init_stacks(), stacks_exports));
    const { render } = await import("ink");
    const { DeploymentUI: DeploymentUI2 } = await Promise.resolve().then(() => (init_deploy2(), deploy_exports));
    const { printDeploymentResults: printDeploymentResults2 } = await Promise.resolve().then(() => (init_deploy2(), deploy_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const { useSTSIdentity: useSTSIdentity2 } = await Promise.resolve().then(() => (init_credentials(), credentials_exports));
    const project = useProject2();
    const identity = await useSTSIdentity2();
    Colors2.line(`${Colors2.primary.bold(`SST v${project.version}`)}`);
    Colors2.gap();
    Colors2.line(
      `${Colors2.primary(`\u279C`)}  ${Colors2.bold("App:")}     ${project.config.name}`
    );
    Colors2.line(`   ${Colors2.bold("Stage:")}   ${project.config.stage}`);
    Colors2.line(`   ${Colors2.bold("Region:")}  ${project.config.region}`);
    Colors2.line(`   ${Colors2.bold("Account:")} ${identity.Account}`);
    const assembly = await async function() {
      if (args.from) {
        const result = await loadAssembly2(args.from);
        return result;
      }
      return await Stacks.synth({
        fn: project.stacks,
        mode: "remove"
      });
    }();
    const target = assembly.stacks.filter(
      (s) => !args.filter || s.id.toLowerCase().replace(project.config.name.toLowerCase(), "").replace(project.config.stage.toLowerCase(), "").includes(args.filter.toLowerCase())
    );
    if (!target.length) {
      console.log(`No stacks found matching ${blue4(args.filter)}`);
      process.exit(1);
    }
    const component = render(
      /* @__PURE__ */ React2.createElement(DeploymentUI2, { assembly, remove: true })
    );
    const results = await Stacks.removeMany(target);
    component.clear();
    component.unmount();
    printDeploymentResults2(assembly, results, true);
    if (Object.values(results).some((stack) => Stacks.isFailed(stack.status)))
      process.exit(1);
    await clearAppMetadata2();
    process.exit(0);
  }
);

// src/cli/commands/console.ts
var consoleCommand = async (program2) => program2.command(
  "console",
  "Start the SST Console",
  (yargs2) => yargs2,
  async () => {
    const { blue: blue4 } = await import("colorette");
    const { useRuntimeServer: useRuntimeServer2 } = await Promise.resolve().then(() => (init_server(), server_exports));
    const { useLocalServer: useLocalServer2 } = await Promise.resolve().then(() => (init_server2(), server_exports2));
    const { printHeader: printHeader2 } = await Promise.resolve().then(() => (init_header(), header_exports));
    const { clear: clear2 } = await Promise.resolve().then(() => (init_terminal(), terminal_exports));
    await Promise.all([
      useRuntimeServer2(),
      useLocalServer2({
        key: "",
        cert: "",
        live: false
      })
    ]);
    clear2();
    printHeader2({ console: true, hint: "ready!" });
  }
);

// src/cli/commands/secrets/get.ts
var get = (program2) => program2.command(
  "get <name>",
  "Get the value of a secret",
  (yargs2) => yargs2.positional("name", {
    type: "string",
    describe: "Name of the secret",
    demandOption: true
  }).option("fallback", {
    type: "boolean",
    describe: "Get the fallback value"
  }),
  async (args) => {
    const { red: red2 } = await import("colorette");
    const { Config: Config2 } = await Promise.resolve().then(() => (init_config(), config_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    try {
      const result = await Config2.getSecret({
        key: args.name,
        fallback: args.fallback === true
      });
      console.log(result);
    } catch {
      Colors2.line(Colors2.danger(`\u2716 `), `"${args.name}" is not set`);
    }
  }
);

// src/cli/commands/secrets/list.ts
var list = (program2) => program2.command(
  "list [format]",
  "Fetch all the secrets",
  (yargs2) => yargs2.positional("format", {
    type: "string",
    choices: ["table", "env"]
  }),
  async (args) => {
    const { Config: Config2 } = await Promise.resolve().then(() => (init_config(), config_exports));
    const { gray } = await import("colorette");
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const secrets2 = await Config2.secrets();
    if (Object.entries(secrets2).length === 0) {
      Colors2.line("No secrets set");
      return;
    }
    switch (args.format || "table") {
      case "env":
        for (const [key, value] of Object.entries(secrets2)) {
          console.log(`${key}=${value.value || value.fallback}`);
        }
        break;
      case "table":
        const keys = Object.keys(secrets2);
        const keyLen = Math.max(
          "Secrets".length,
          ...keys.map((key) => key.length)
        );
        const valueLen = Math.max(
          "Values".length,
          ...keys.map(
            (key) => secrets2[key].value ? secrets2[key].value.length : `${secrets2[key].fallback} (fallback)`.length
          )
        );
        console.log(
          "\u250C".padEnd(keyLen + 3, "\u2500") + "\u252C" + "".padEnd(valueLen + 2, "\u2500") + "\u2510"
        );
        console.log(
          `\u2502 ${"Secrets".padEnd(keyLen)} \u2502 ${"Values".padEnd(valueLen)} \u2502`
        );
        console.log(
          "\u251C".padEnd(keyLen + 3, "\u2500") + "\u253C" + "".padEnd(valueLen + 2, "\u2500") + "\u2524"
        );
        keys.sort().forEach((key) => {
          const value = secrets2[key].value ? secrets2[key].value : `${secrets2[key].fallback} ${gray("(fallback)")}`;
          console.log(
            `\u2502 ${key.padEnd(keyLen)} \u2502 ${value.padEnd(valueLen)} \u2502`
          );
        });
        console.log(
          "\u2514".padEnd(keyLen + 3, "\u2500") + "\u2534" + "".padEnd(valueLen + 2, "\u2500") + "\u2518"
        );
        break;
    }
  }
);

// src/cli/commands/secrets/load.ts
var load2 = (program2) => program2.command(
  "load <filename>",
  "Loads secrets from an .env file",
  (yargs2) => yargs2.positional("filename", {
    type: "string",
    demandOption: true
  }),
  async (args) => {
    const { Config: Config2 } = await Promise.resolve().then(() => (init_config(), config_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const { blue: blue4 } = await import("colorette");
    const { createSpinner: createSpinner2 } = await Promise.resolve().then(() => (init_spinner(), spinner_exports));
    const { parse: parse2 } = await import("dotenv");
    const fs18 = await import("fs/promises");
    const fileContent = await fs18.readFile(args.filename, "utf-8");
    const envVars = parse2(fileContent);
    const setting = createSpinner2(
      ` Setting secrets from "${args.filename}"`
    ).start();
    for (const [key, value] of Object.entries(envVars)) {
      await Config2.setSecret({ key, value });
    }
    setting.succeed();
    const envNames = Object.keys(envVars);
    const restarting = createSpinner2(
      ` Restarting all resources using ${blue4(envNames.join(", "))}...`
    ).start();
    const { edgeSites, sites, placeholderSites, functions } = await Config2.restart(envNames);
    restarting.stop().clear();
    const siteCount = sites.length + placeholderSites.length;
    if (siteCount > 0) {
      Colors2.line(
        Colors2.success(`\u2714 `),
        siteCount === 1 ? `Reloaded ${siteCount} site` : `Reloaded ${siteCount} sites`
      );
    }
    const functionCount = functions.length;
    if (functionCount > 0) {
      Colors2.line(
        Colors2.success(`\u2714 `),
        functionCount === 1 ? `Reloaded ${functionCount} function` : `Reloaded ${functionCount} functions`
      );
    }
    edgeSites.forEach(({ id, type }) => {
      Colors2.line(
        Colors2.primary(`\u279C `),
        `Redeploy the "${id}" ${type} to use the new secret`
      );
    });
    process.exit(0);
  }
);

// src/cli/commands/secrets/remove.ts
var remove3 = (program2) => program2.command(
  "remove <name>",
  "Remove a secret",
  (yargs2) => yargs2.positional("name", {
    describe: "Name of the secret",
    type: "string",
    demandOption: true
  }).option("fallback", {
    type: "boolean",
    describe: "Remove the fallback value"
  }),
  async (args) => {
    const { Config: Config2 } = await Promise.resolve().then(() => (init_config(), config_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    try {
      await Config2.removeSecret({
        key: args.name,
        fallback: args.fallback === true
      });
      Colors2.line(Colors2.success(`\u2714 `), `Removed "${args.name}"`);
    } catch {
      Colors2.line(Colors2.danger(`\u2716 `), `"${args.name}" is not set`);
    }
  }
);

// src/cli/commands/secrets/set.ts
var set = (program2) => program2.command(
  "set <name> <value>",
  "Set the value of a secret",
  (yargs2) => yargs2.positional("name", {
    type: "string",
    describe: "Name of the secret",
    demandOption: true
  }).positional("value", {
    type: "string",
    describe: "Value of the secret",
    demandOption: true
  }).option("fallback", {
    type: "boolean",
    describe: "Set the fallback value"
  }),
  async (args) => {
    const { Config: Config2 } = await Promise.resolve().then(() => (init_config(), config_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const { blue: blue4 } = await import("colorette");
    const { createSpinner: createSpinner2 } = await Promise.resolve().then(() => (init_spinner(), spinner_exports));
    const setting = createSpinner2(` Setting "${args.name}"`).start();
    await Config2.setSecret({
      key: args.name,
      value: args.value,
      fallback: args.fallback === true
    });
    setting.succeed();
    const restarting = createSpinner2(
      ` Reloading all resources using ${blue4(args.name)}...`
    ).start();
    const { edgeSites, sites, placeholderSites, functions } = await Config2.restart([args.name]);
    restarting.stop().clear();
    const siteCount = sites.length + placeholderSites.length;
    if (siteCount > 0) {
      Colors2.line(
        Colors2.success(`\u2714 `),
        siteCount === 1 ? `Reloaded ${siteCount} site` : `Reloaded ${siteCount} sites`
      );
    }
    const functionCount = functions.length;
    if (functionCount > 0) {
      Colors2.line(
        Colors2.success(`\u2714 `),
        functionCount === 1 ? `Reloaded ${functionCount} function` : `Reloaded ${functionCount} functions`
      );
    }
    edgeSites.forEach(({ id, type }) => {
      Colors2.line(
        Colors2.primary(`\u279C `),
        `Redeploy the "${id}" ${type} to use the new secret`
      );
    });
    process.exit(0);
  }
);

// src/cli/commands/secrets/secrets.ts
function secrets(program2) {
  program2.command("secrets", "Manage the secrets in your app", (yargs2) => {
    yargs2.demandCommand(1);
    set(yargs2);
    get(yargs2);
    load2(yargs2);
    list(yargs2);
    remove3(yargs2);
    return yargs2;
  });
}

// src/cli/commands/update.ts
var PACKAGE_MATCH = [
  "sst",
  "astro-sst",
  "aws-cdk",
  "@aws-cdk",
  "constructs",
  "solid-start-sst"
];
var FIELDS = ["dependencies", "devDependencies"];
var update = (program2) => program2.command(
  "update [version]",
  "Update your SST and CDK packages",
  (yargs2) => yargs2.positional("version", {
    type: "string",
    describe: "Optionally specify a version to update to"
  }),
  async (args) => {
    const { green, yellow } = await import("colorette");
    const fs18 = await import("fs/promises");
    const path20 = await import("path");
    const { fetch } = await import("undici");
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    async function find2(dir) {
      const children = await fs18.readdir(dir);
      const tasks2 = children.map(async (item) => {
        if (item === "node_modules")
          return [];
        if (/(^|\/)\.[^\/\.]/g.test(item))
          return [];
        const full = path20.join(dir, item);
        if (item === "package.json")
          return [full];
        const stat = await fs18.stat(full);
        if (stat.isDirectory())
          return find2(full);
        return [];
      });
      return (await Promise.all(tasks2)).flat();
    }
    const project = useProject2();
    const files = await find2(project.paths.root);
    const metadata3 = await fetch(
      `https://registry.npmjs.org/sst/${args.version || "latest"}`
    ).then((resp) => resp.json());
    const results = /* @__PURE__ */ new Map();
    const tasks = files.map(async (file) => {
      const data2 = await fs18.readFile(file).then((x) => x.toString()).then(JSON.parse);
      for (const field of FIELDS) {
        const deps = data2[field];
        if (!deps)
          continue;
        for (const [pkg, existing] of Object.entries(deps)) {
          if (!PACKAGE_MATCH.some((x) => pkg.startsWith(x)))
            continue;
          const desired = (() => {
            if (["sst", "astro-sst"].includes(pkg))
              return metadata3.version;
            if (pkg === "constructs")
              return metadata3.dependencies.constructs;
            if (pkg.endsWith("alpha"))
              return metadata3.dependencies["@aws-cdk/aws-apigatewayv2-alpha"];
            return metadata3.dependencies["aws-cdk-lib"];
          })();
          if (existing === desired)
            continue;
          let arr = results.get(file);
          if (!arr) {
            arr = /* @__PURE__ */ new Set();
            results.set(file, arr);
          }
          arr.add([pkg, desired]);
          deps[pkg] = desired;
        }
      }
      if (results.has(file)) {
        await fs18.writeFile(file, JSON.stringify(data2, null, 2));
      }
    });
    await Promise.all(tasks);
    if (results.size === 0) {
      Colors2.line(Colors2.success(`\u2714 `), `Already using v${metadata3.version}`);
      return;
    }
    for (const [file, pkgs] of results.entries()) {
      Colors2.line(
        Colors2.success(`\u2714 `),
        Colors2.bold.dim(path20.relative(project.paths.root, file))
      );
      for (const [pkg, version2] of pkgs) {
        Colors2.line(Colors2.dim(`   ${pkg}@${version2}`));
      }
    }
    Colors2.gap();
    Colors2.line(
      `${Colors2.primary(`\u279C`)}  ${Colors2.warning(
        "Make sure to run: npm install (or pnpm install, or yarn)"
      )}`
    );
    process.exit(0);
  }
);

// src/cli/commands/transform.ts
var transform = (program2) => program2.command(
  "transform <mod>",
  "Apply a transform to your SST app",
  (yargs2) => yargs2.positional("mod", {
    type: "string",
    describe: "Name of the transform",
    demandOption: true
  }),
  async (args) => {
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    if (args.mod === "resource-binding-secrets") {
      await handleSecretsMigration();
      Colors2.line(
        Colors2.success(`\u2714 `),
        `Transform "${args.mod}" applied successfully!`
      );
      return;
    }
    Colors2.line(Colors2.danger(`\u2716 `), `Transform "${args.mod}" not found`);
  }
);
async function handleSecretsMigration() {
  const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
  const { useAWSClient: useAWSClient2 } = await Promise.resolve().then(() => (init_credentials(), credentials_exports));
  const { SSMClient: SSMClient2, GetParametersByPathCommand: GetParametersByPathCommand2, PutParameterCommand: PutParameterCommand2 } = await import("@aws-sdk/client-ssm");
  const project = useProject2();
  const { name: app, stage } = project.config;
  const ssm = useAWSClient2(SSMClient2);
  async function* getAllPrametersByPath(prefix) {
    let token;
    while (true) {
      const results = await ssm.send(
        new GetParametersByPathCommand2({
          Path: prefix,
          WithDecryption: true,
          Recursive: true,
          NextToken: token
        })
      );
      yield* results.Parameters || [];
      if (!results.NextToken)
        break;
      token = results.NextToken;
    }
  }
  async function migrateSecretsSSMPath(stage2) {
    const oldPrefix = `/sst/${app}/${stage2}/secrets/`;
    const newPrefix = `/sst/${app}/${stage2}/Secret/`;
    for await (const secret of getAllPrametersByPath(oldPrefix)) {
      const name = secret.Name.split("/")[5];
      if (name === "SST_AUTH_PRIVATE" || name === "SST_AUTH_PUBLIC") {
        continue;
      }
      await ssm.send(
        new PutParameterCommand2({
          Name: `${newPrefix}${name}/value`,
          Value: secret.Value,
          Type: secret.Type,
          Overwrite: true
        })
      );
    }
  }
  await migrateSecretsSSMPath(stage);
  await migrateSecretsSSMPath(".fallback");
}

// src/cli/ui/stack.ts
init_project();
function stackNameToId2(stack) {
  const project = useProject();
  const prefix = `${project.config.stage}-${project.config.name}-`;
  return stack.startsWith(prefix) ? stack.substring(prefix.length) : stack;
}

// src/cli/commands/diff.ts
var diff2 = (program2) => program2.command(
  "diff",
  "Compare your app with what is deployed on AWS",
  (yargs2) => yargs2.option("dev", {
    type: "boolean",
    describe: "Compare in dev mode"
  }),
  async (args) => {
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const { Stacks } = await Promise.resolve().then(() => (init_stacks(), stacks_exports));
    const { useAWSClient: useAWSClient2 } = await Promise.resolve().then(() => (init_credentials(), credentials_exports));
    const { CloudFormationClient: CloudFormationClient4, GetTemplateCommand } = await import("@aws-sdk/client-cloudformation");
    const { createSpinner: createSpinner2 } = await Promise.resolve().then(() => (init_spinner(), spinner_exports));
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const project = useProject2();
    const assembly = await Stacks.synth({
      fn: project.stacks,
      mode: args.dev ? "dev" : "deploy"
    });
    let changesAcc = 0;
    let changedStacks = 0;
    const cfn = useAWSClient2(CloudFormationClient4);
    for (const stack of assembly.stacks) {
      const spinner = createSpinner2(
        `${stack.stackName}: Checking for changes...`
      );
      const oldTemplate = await getTemplate(stack.stackName);
      if (!oldTemplate) {
        spinner.clear();
        Colors2.line(
          `\u279C  ${Colors2.dim.bold(
            stackNameToId2(stack.stackName) + ":"
          )} New stack`
        );
        Colors2.gap();
        continue;
      }
      const { count, diff: diff3 } = await Stacks.diff(stack, oldTemplate);
      spinner.clear();
      if (count === 0) {
        Colors2.line(
          `\u279C  ${Colors2.dim.bold(
            stackNameToId2(stack.stackName) + ":"
          )} No changes`
        );
        Colors2.gap();
      } else if (count === 1) {
        Colors2.line(
          `\u279C  ${Colors2.dim.bold(
            stackNameToId2(stack.stackName) + ":"
          )} ${count} change`
        );
        Colors2.gap();
        console.log(diff3);
        changesAcc += count;
        changedStacks++;
      } else {
        Colors2.line(
          `\u279C  ${Colors2.dim.bold(
            stackNameToId2(stack.stackName) + ":"
          )} ${count} changes`
        );
        Colors2.gap();
        console.log(diff3);
        changesAcc += count;
        changedStacks++;
      }
    }
    if (changedStacks === 0) {
      Colors2.line(Colors2.success(`\u2714`), Colors2.bold(" Diff:"), "No changes");
    } else {
      Colors2.line(
        Colors2.success(`\u2714`),
        Colors2.bold(" Diff:"),
        changesAcc === 1 ? "1 change found in" : `${changesAcc} changes in`,
        changedStacks === 1 ? "1 stack" : `${changedStacks} stacks`
      );
    }
    process.exit(0);
    async function getTemplate(stackName) {
      try {
        const response = await cfn.send(
          new GetTemplateCommand({ StackName: stackName })
        );
        return JSON.parse(response.TemplateBody);
      } catch (e) {
        if (e.name === "ValidationError" && e.message.includes("does not exist")) {
          return;
        }
        throw e;
      }
    }
  }
);

// src/cli/commands/version.ts
var version = (program2) => program2.command(
  "version",
  "Print SST and CDK version",
  (yargs2) => yargs2,
  async (args) => {
    const { Colors: Colors2 } = await Promise.resolve().then(() => (init_colors(), colors_exports));
    const { useProject: useProject2 } = await Promise.resolve().then(() => (init_project(), project_exports));
    const project = useProject2();
    Colors2.line(Colors2.bold(`SST:`), `v${project.version}`);
    Colors2.line(Colors2.bold(`CDK:`), `v${project.cdkVersion}`);
    Colors2.line(Colors2.bold(`Constructs:`), `v${project.constructsVersion}`);
  }
);

// src/cli/commands/telemetry.ts
init_colors();
var telemetry = (program2) => program2.command(
  "telemetry <action>",
  "Load environment variables and start your frontend",
  (yargs2) => yargs2.positional("action", {
    type: "string",
    describe: "Whether to enable or disable",
    choices: ["enable", "disable"],
    demandOption: true
  }),
  async (args) => {
    const { enable: enable2, disable: disable2 } = await Promise.resolve().then(() => (init_telemetry(), telemetry_exports));
    if (args.action === "enable") {
      enable2();
      Colors.line(Colors.success(`\u2714 `), `Telemetry enabled`);
    }
    if (args.action === "disable") {
      disable2();
      Colors.line(Colors.success(`\u2714 `), `Telemetry disabled`);
    }
  }
);

// src/cli/sst.ts
dotenv2.config({
  override: true
});
dotenv2.config({
  path: ".env.local",
  override: true
});
bootstrap(program);
dev(program);
deploy2(program);
build(program);
bind(program);
secrets(program);
remove2(program);
update(program);
transform(program);
consoleCommand(program);
diff2(program);
version(program);
telemetry(program);
if ("setSourceMapsEnabled" in process) {
  process.setSourceMapsEnabled(true);
}
process.removeAllListeners("uncaughtException");
process.on("uncaughtException", (err) => {
  Logger.debug(err);
  const spinners = useSpinners();
  for (const spinner of spinners) {
    if (spinner.isSpinning)
      spinner.fail(spinner.text);
  }
  console.log(red("Error:"), err.message);
  if (!(err instanceof VisibleError)) {
    console.log();
    console.trace(err.stack);
  }
  console.log();
  console.log(
    `Need help with this error? Join the SST community on Discord ${blue3(
      `https://sst.dev/discord`
    )}`
  );
  process.exit(1);
});
process.on("beforeExit", () => {
});
var nodeVersion = process.versions.node;
if (Number(nodeVersion.split(".")[0]) < 16) {
  throw new VisibleError(
    `Node.js version ${nodeVersion} is not supported by SST. Please upgrade to Node.js 16 or later.`
  );
}
program.parse();
